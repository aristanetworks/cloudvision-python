"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import arista.configlet.v1.configlet_pb2
import arista.subscriptions.subscriptions_pb2
import arista.time.time_pb2
import builtins
import fmp.deletes_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import google.protobuf.timestamp_pb2
import google.protobuf.wrappers_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class MetaResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    COUNT_FIELD_NUMBER: builtins.int
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time holds the timestamp of the last item included in the metadata calculation."""
        pass
    type: arista.subscriptions.subscriptions_pb2.Operation.ValueType
    """Operation indicates how the value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """

    @property
    def count(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Count is the number of items present under the conditions of the request."""
        pass
    def __init__(self,
        *,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        type: arista.subscriptions.subscriptions_pb2.Operation.ValueType = ...,
        count: typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["count",b"count","time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["count",b"count","time",b"time","type",b"type"]) -> None: ...
global___MetaResponse = MetaResponse

class ConfigletRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.configlet.v1.configlet_pb2.ConfigletKey:
        """Key uniquely identifies a Configlet instance to retrieve.
        This value must be populated.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """
        pass
    def __init__(self,
        *,
        key: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletKey] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["key",b"key","time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["key",b"key","time",b"time"]) -> None: ...
global___ConfigletRequest = ConfigletRequest

class ConfigletResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.configlet.v1.configlet_pb2.Configlet:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        Configlet instance in this response.
        """
        pass
    def __init__(self,
        *,
        value: typing.Optional[arista.configlet.v1.configlet_pb2.Configlet] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["time",b"time","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["time",b"time","value",b"value"]) -> None: ...
global___ConfigletResponse = ConfigletResponse

class ConfigletSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEYS_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.ConfigletKey]: ...
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """
        pass
    def __init__(self,
        *,
        keys: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.ConfigletKey]] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["keys",b"keys","time",b"time"]) -> None: ...
global___ConfigletSomeRequest = ConfigletSomeRequest

class ConfigletSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.configlet.v1.configlet_pb2.Configlet:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """
        pass
    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """Error is an optional field.
        It should be filled when there is an error in the GetSome process.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp: ...
    def __init__(self,
        *,
        value: typing.Optional[arista.configlet.v1.configlet_pb2.Configlet] = ...,
        error: typing.Optional[google.protobuf.wrappers_pb2.StringValue] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["error",b"error","time",b"time","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["error",b"error","time",b"time","value",b"value"]) -> None: ...
global___ConfigletSomeResponse = ConfigletSomeResponse

class ConfigletStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.Configlet]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """
        pass
    @property
    def filter(self) -> arista.configlet.v1.configlet_pb2.Filter:
        """For each Configlet in the list, all populated fields are considered ANDed together
        as a filtering operation. Similarly, the list itself is ORed such that any individual
        filter that matches a given Configlet is streamed to the user.
        """
        pass
    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each Configlet at end.
            * Each Configlet response is fully-specified (all fields set).
          * start: Returns the state of each Configlet at start, followed by updates until now.
            * Each Configlet response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each Configlet at start, followed by updates
            until end.
            * Each Configlet response at start is fully-specified, but updates until end may
              be partial.

        This field is not allowed in the Subscribe RPC.
        """
        pass
    def __init__(self,
        *,
        partial_eq_filter: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.Configlet]] = ...,
        filter: typing.Optional[arista.configlet.v1.configlet_pb2.Filter] = ...,
        time: typing.Optional[arista.time.time_pb2.TimeBounds] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["filter",b"filter","time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["filter",b"filter","partial_eq_filter",b"partial_eq_filter","time",b"time"]) -> None: ...
global___ConfigletStreamRequest = ConfigletStreamRequest

class ConfigletStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.configlet.v1.configlet_pb2.Configlet:
        """Value is a value deemed relevant to the initiating request.
        This structure will always have its key-field populated. Which other fields are
        populated, and why, depends on the value of Operation and what triggered this notification.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time holds the timestamp of this Configlet's last modification."""
        pass
    type: arista.subscriptions.subscriptions_pb2.Operation.ValueType
    """Operation indicates how the Configlet value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """

    def __init__(self,
        *,
        value: typing.Optional[arista.configlet.v1.configlet_pb2.Configlet] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        type: arista.subscriptions.subscriptions_pb2.Operation.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["time",b"time","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["time",b"time","type",b"type","value",b"value"]) -> None: ...
global___ConfigletStreamResponse = ConfigletStreamResponse

class ConfigletBatchedStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    MAX_MESSAGES_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.Configlet]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """
        pass
    @property
    def filter(self) -> arista.configlet.v1.configlet_pb2.Filter:
        """For each Configlet in the list, all populated fields are considered ANDed together
        as a filtering operation. Similarly, the list itself is ORed such that any individual
        filter that matches a given Configlet is streamed to the user.
        """
        pass
    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each Configlet at end.
            * Each Configlet response is fully-specified (all fields set).
          * start: Returns the state of each Configlet at start, followed by updates until now.
            * Each Configlet response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each Configlet at start, followed by updates
            until end.
            * Each Configlet response at start is fully-specified, but updates until end may
              be partial.

        This field is not allowed in the Subscribe RPC.
        """
        pass
    @property
    def max_messages(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """MaxMessages limits the maximum number of messages that can be contained in one batch.
        MaxMessages is required to be at least 1.
        The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
        INTERNAL_BATCH_LIMIT is set based on the maximum message size.
        """
        pass
    def __init__(self,
        *,
        partial_eq_filter: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.Configlet]] = ...,
        filter: typing.Optional[arista.configlet.v1.configlet_pb2.Filter] = ...,
        time: typing.Optional[arista.time.time_pb2.TimeBounds] = ...,
        max_messages: typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["filter",b"filter","max_messages",b"max_messages","time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["filter",b"filter","max_messages",b"max_messages","partial_eq_filter",b"partial_eq_filter","time",b"time"]) -> None: ...
global___ConfigletBatchedStreamRequest = ConfigletBatchedStreamRequest

class ConfigletBatchedStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    RESPONSES_FIELD_NUMBER: builtins.int
    @property
    def responses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ConfigletStreamResponse]:
        """Values are the values deemed relevant to the initiating request.
        The length of this structure is guaranteed to be between (inclusive) 1 and 
        min(req.max_messages, INTERNAL_BATCH_LIMIT).
        """
        pass
    def __init__(self,
        *,
        responses: typing.Optional[typing.Iterable[global___ConfigletStreamResponse]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["responses",b"responses"]) -> None: ...
global___ConfigletBatchedStreamResponse = ConfigletBatchedStreamResponse

class ConfigletAssignmentRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey:
        """Key uniquely identifies a ConfigletAssignment instance to retrieve.
        This value must be populated.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """
        pass
    def __init__(self,
        *,
        key: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["key",b"key","time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["key",b"key","time",b"time"]) -> None: ...
global___ConfigletAssignmentRequest = ConfigletAssignmentRequest

class ConfigletAssignmentResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.configlet.v1.configlet_pb2.ConfigletAssignment:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        ConfigletAssignment instance in this response.
        """
        pass
    def __init__(self,
        *,
        value: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletAssignment] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["time",b"time","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["time",b"time","value",b"value"]) -> None: ...
global___ConfigletAssignmentResponse = ConfigletAssignmentResponse

class ConfigletAssignmentSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEYS_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey]: ...
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """
        pass
    def __init__(self,
        *,
        keys: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey]] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["keys",b"keys","time",b"time"]) -> None: ...
global___ConfigletAssignmentSomeRequest = ConfigletAssignmentSomeRequest

class ConfigletAssignmentSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.configlet.v1.configlet_pb2.ConfigletAssignment:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """
        pass
    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """Error is an optional field.
        It should be filled when there is an error in the GetSome process.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp: ...
    def __init__(self,
        *,
        value: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletAssignment] = ...,
        error: typing.Optional[google.protobuf.wrappers_pb2.StringValue] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["error",b"error","time",b"time","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["error",b"error","time",b"time","value",b"value"]) -> None: ...
global___ConfigletAssignmentSomeResponse = ConfigletAssignmentSomeResponse

class ConfigletAssignmentStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.ConfigletAssignment]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """
        pass
    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each ConfigletAssignment at end.
            * Each ConfigletAssignment response is fully-specified (all fields set).
          * start: Returns the state of each ConfigletAssignment at start, followed by updates until now.
            * Each ConfigletAssignment response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each ConfigletAssignment at start, followed by updates
            until end.
            * Each ConfigletAssignment response at start is fully-specified, but updates until end may
              be partial.

        This field is not allowed in the Subscribe RPC.
        """
        pass
    def __init__(self,
        *,
        partial_eq_filter: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.ConfigletAssignment]] = ...,
        time: typing.Optional[arista.time.time_pb2.TimeBounds] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["partial_eq_filter",b"partial_eq_filter","time",b"time"]) -> None: ...
global___ConfigletAssignmentStreamRequest = ConfigletAssignmentStreamRequest

class ConfigletAssignmentStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.configlet.v1.configlet_pb2.ConfigletAssignment:
        """Value is a value deemed relevant to the initiating request.
        This structure will always have its key-field populated. Which other fields are
        populated, and why, depends on the value of Operation and what triggered this notification.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time holds the timestamp of this ConfigletAssignment's last modification."""
        pass
    type: arista.subscriptions.subscriptions_pb2.Operation.ValueType
    """Operation indicates how the ConfigletAssignment value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """

    def __init__(self,
        *,
        value: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletAssignment] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        type: arista.subscriptions.subscriptions_pb2.Operation.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["time",b"time","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["time",b"time","type",b"type","value",b"value"]) -> None: ...
global___ConfigletAssignmentStreamResponse = ConfigletAssignmentStreamResponse

class ConfigletAssignmentBatchedStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    MAX_MESSAGES_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.ConfigletAssignment]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """
        pass
    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each ConfigletAssignment at end.
            * Each ConfigletAssignment response is fully-specified (all fields set).
          * start: Returns the state of each ConfigletAssignment at start, followed by updates until now.
            * Each ConfigletAssignment response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each ConfigletAssignment at start, followed by updates
            until end.
            * Each ConfigletAssignment response at start is fully-specified, but updates until end may
              be partial.

        This field is not allowed in the Subscribe RPC.
        """
        pass
    @property
    def max_messages(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """MaxMessages limits the maximum number of messages that can be contained in one batch.
        MaxMessages is required to be at least 1.
        The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
        INTERNAL_BATCH_LIMIT is set based on the maximum message size.
        """
        pass
    def __init__(self,
        *,
        partial_eq_filter: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.ConfigletAssignment]] = ...,
        time: typing.Optional[arista.time.time_pb2.TimeBounds] = ...,
        max_messages: typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["max_messages",b"max_messages","time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["max_messages",b"max_messages","partial_eq_filter",b"partial_eq_filter","time",b"time"]) -> None: ...
global___ConfigletAssignmentBatchedStreamRequest = ConfigletAssignmentBatchedStreamRequest

class ConfigletAssignmentBatchedStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    RESPONSES_FIELD_NUMBER: builtins.int
    @property
    def responses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ConfigletAssignmentStreamResponse]:
        """Values are the values deemed relevant to the initiating request.
        The length of this structure is guaranteed to be between (inclusive) 1 and 
        min(req.max_messages, INTERNAL_BATCH_LIMIT).
        """
        pass
    def __init__(self,
        *,
        responses: typing.Optional[typing.Iterable[global___ConfigletAssignmentStreamResponse]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["responses",b"responses"]) -> None: ...
global___ConfigletAssignmentBatchedStreamResponse = ConfigletAssignmentBatchedStreamResponse

class ConfigletAssignmentConfigRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey:
        """Key uniquely identifies a ConfigletAssignmentConfig instance to retrieve.
        This value must be populated.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """
        pass
    def __init__(self,
        *,
        key: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["key",b"key","time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["key",b"key","time",b"time"]) -> None: ...
global___ConfigletAssignmentConfigRequest = ConfigletAssignmentConfigRequest

class ConfigletAssignmentConfigResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        ConfigletAssignmentConfig instance in this response.
        """
        pass
    def __init__(self,
        *,
        value: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["time",b"time","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["time",b"time","value",b"value"]) -> None: ...
global___ConfigletAssignmentConfigResponse = ConfigletAssignmentConfigResponse

class ConfigletAssignmentConfigSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEYS_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey]: ...
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """
        pass
    def __init__(self,
        *,
        keys: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey]] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["keys",b"keys","time",b"time"]) -> None: ...
global___ConfigletAssignmentConfigSomeRequest = ConfigletAssignmentConfigSomeRequest

class ConfigletAssignmentConfigSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """
        pass
    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """Error is an optional field.
        It should be filled when there is an error in the GetSome process.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp: ...
    def __init__(self,
        *,
        value: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig] = ...,
        error: typing.Optional[google.protobuf.wrappers_pb2.StringValue] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["error",b"error","time",b"time","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["error",b"error","time",b"time","value",b"value"]) -> None: ...
global___ConfigletAssignmentConfigSomeResponse = ConfigletAssignmentConfigSomeResponse

class ConfigletAssignmentConfigStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """
        pass
    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each ConfigletAssignmentConfig at end.
            * Each ConfigletAssignmentConfig response is fully-specified (all fields set).
          * start: Returns the state of each ConfigletAssignmentConfig at start, followed by updates until now.
            * Each ConfigletAssignmentConfig response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each ConfigletAssignmentConfig at start, followed by updates
            until end.
            * Each ConfigletAssignmentConfig response at start is fully-specified, but updates until end may
              be partial.

        This field is not allowed in the Subscribe RPC.
        """
        pass
    def __init__(self,
        *,
        partial_eq_filter: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig]] = ...,
        time: typing.Optional[arista.time.time_pb2.TimeBounds] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["partial_eq_filter",b"partial_eq_filter","time",b"time"]) -> None: ...
global___ConfigletAssignmentConfigStreamRequest = ConfigletAssignmentConfigStreamRequest

class ConfigletAssignmentConfigStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig:
        """Value is a value deemed relevant to the initiating request.
        This structure will always have its key-field populated. Which other fields are
        populated, and why, depends on the value of Operation and what triggered this notification.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time holds the timestamp of this ConfigletAssignmentConfig's last modification."""
        pass
    type: arista.subscriptions.subscriptions_pb2.Operation.ValueType
    """Operation indicates how the ConfigletAssignmentConfig value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """

    def __init__(self,
        *,
        value: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        type: arista.subscriptions.subscriptions_pb2.Operation.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["time",b"time","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["time",b"time","type",b"type","value",b"value"]) -> None: ...
global___ConfigletAssignmentConfigStreamResponse = ConfigletAssignmentConfigStreamResponse

class ConfigletAssignmentConfigBatchedStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    MAX_MESSAGES_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """
        pass
    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each ConfigletAssignmentConfig at end.
            * Each ConfigletAssignmentConfig response is fully-specified (all fields set).
          * start: Returns the state of each ConfigletAssignmentConfig at start, followed by updates until now.
            * Each ConfigletAssignmentConfig response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each ConfigletAssignmentConfig at start, followed by updates
            until end.
            * Each ConfigletAssignmentConfig response at start is fully-specified, but updates until end may
              be partial.

        This field is not allowed in the Subscribe RPC.
        """
        pass
    @property
    def max_messages(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """MaxMessages limits the maximum number of messages that can be contained in one batch.
        MaxMessages is required to be at least 1.
        The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
        INTERNAL_BATCH_LIMIT is set based on the maximum message size.
        """
        pass
    def __init__(self,
        *,
        partial_eq_filter: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig]] = ...,
        time: typing.Optional[arista.time.time_pb2.TimeBounds] = ...,
        max_messages: typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["max_messages",b"max_messages","time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["max_messages",b"max_messages","partial_eq_filter",b"partial_eq_filter","time",b"time"]) -> None: ...
global___ConfigletAssignmentConfigBatchedStreamRequest = ConfigletAssignmentConfigBatchedStreamRequest

class ConfigletAssignmentConfigBatchedStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    RESPONSES_FIELD_NUMBER: builtins.int
    @property
    def responses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ConfigletAssignmentConfigStreamResponse]:
        """Values are the values deemed relevant to the initiating request.
        The length of this structure is guaranteed to be between (inclusive) 1 and 
        min(req.max_messages, INTERNAL_BATCH_LIMIT).
        """
        pass
    def __init__(self,
        *,
        responses: typing.Optional[typing.Iterable[global___ConfigletAssignmentConfigStreamResponse]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["responses",b"responses"]) -> None: ...
global___ConfigletAssignmentConfigBatchedStreamResponse = ConfigletAssignmentConfigBatchedStreamResponse

class ConfigletAssignmentConfigSetRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUE_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig:
        """ConfigletAssignmentConfig carries the value to set into the datastore.
        See the documentation on the ConfigletAssignmentConfig struct for which fields are required.
        """
        pass
    def __init__(self,
        *,
        value: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["value",b"value"]) -> None: ...
global___ConfigletAssignmentConfigSetRequest = ConfigletAssignmentConfigSetRequest

class ConfigletAssignmentConfigSetResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig:
        """Value carries all the values given in the ConfigletAssignmentConfigSetRequest as well
        as any server-generated values.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp at which the system recognizes the
        creation. The only guarantees made about this timestamp are:

           - it is after the time the request was received
           - a time-ranged query with StartTime==CreatedAt will include this instance.
        """
        pass
    def __init__(self,
        *,
        value: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["time",b"time","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["time",b"time","value",b"value"]) -> None: ...
global___ConfigletAssignmentConfigSetResponse = ConfigletAssignmentConfigSetResponse

class ConfigletAssignmentConfigSetSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUES_FIELD_NUMBER: builtins.int
    @property
    def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig]:
        """value contains a list of ConfigletAssignmentConfig values to write.
        It is possible to provide more values than can fit within either:
            - the maxiumum send size of the client
            - the maximum receive size of the server
        If this error occurs you must reduce the number of values sent.
        See gRPC "maximum message size" documentation for more information.
        """
        pass
    def __init__(self,
        *,
        values: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["values",b"values"]) -> None: ...
global___ConfigletAssignmentConfigSetSomeRequest = ConfigletAssignmentConfigSetSomeRequest

class ConfigletAssignmentConfigSetSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEY_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey: ...
    error: typing.Text
    def __init__(self,
        *,
        key: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey] = ...,
        error: typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["key",b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["error",b"error","key",b"key"]) -> None: ...
global___ConfigletAssignmentConfigSetSomeResponse = ConfigletAssignmentConfigSetSomeResponse

class ConfigletAssignmentConfigDeleteRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEY_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey:
        """Key indicates which ConfigletAssignmentConfig instance to remove.
        This field must always be set.
        """
        pass
    def __init__(self,
        *,
        key: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["key",b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["key",b"key"]) -> None: ...
global___ConfigletAssignmentConfigDeleteRequest = ConfigletAssignmentConfigDeleteRequest

class ConfigletAssignmentConfigDeleteResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey:
        """Key echoes back the key of the deleted ConfigletAssignmentConfig instance."""
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp at which the system recognizes the
        deletion. The only guarantees made about this timestamp are:

           - it is after the time the request was received
           - a time-ranged query with StartTime==DeletedAt will not include this instance.
        """
        pass
    def __init__(self,
        *,
        key: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["key",b"key","time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["key",b"key","time",b"time"]) -> None: ...
global___ConfigletAssignmentConfigDeleteResponse = ConfigletAssignmentConfigDeleteResponse

class ConfigletAssignmentConfigDeleteSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEYS_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey]:
        """key contains a list of ConfigletAssignmentConfig keys to delete"""
        pass
    def __init__(self,
        *,
        keys: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["keys",b"keys"]) -> None: ...
global___ConfigletAssignmentConfigDeleteSomeRequest = ConfigletAssignmentConfigDeleteSomeRequest

class ConfigletAssignmentConfigDeleteSomeResponse(google.protobuf.message.Message):
    """ConfigletAssignmentConfigDeleteSomeResponse is only sent when there is an error."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEY_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey: ...
    error: typing.Text
    def __init__(self,
        *,
        key: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey] = ...,
        error: typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["key",b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["error",b"error","key",b"key"]) -> None: ...
global___ConfigletAssignmentConfigDeleteSomeResponse = ConfigletAssignmentConfigDeleteSomeResponse

class ConfigletAssignmentConfigDeleteAllRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig]:
        """PartialEqFilter provides a way to server-side filter a DeleteAll.
        This requires all provided fields to be equal to the response.
        A filtered DeleteAll will use GetAll with filter to find things to delete.
        """
        pass
    def __init__(self,
        *,
        partial_eq_filter: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.ConfigletAssignmentConfig]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["partial_eq_filter",b"partial_eq_filter"]) -> None: ...
global___ConfigletAssignmentConfigDeleteAllRequest = ConfigletAssignmentConfigDeleteAllRequest

class ConfigletAssignmentConfigDeleteAllResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    TYPE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    type: fmp.deletes_pb2.DeleteError.ValueType
    """This describes the class of delete error.
    A DeleteAllResponse is only sent when there is an error.
    """

    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """This indicates the error message from the delete failure."""
        pass
    @property
    def key(self) -> arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey:
        """This is the key of the ConfigletAssignmentConfig instance that failed to be deleted."""
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp when the key was being deleted."""
        pass
    def __init__(self,
        *,
        type: fmp.deletes_pb2.DeleteError.ValueType = ...,
        error: typing.Optional[google.protobuf.wrappers_pb2.StringValue] = ...,
        key: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletAssignmentKey] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["error",b"error","key",b"key","time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["error",b"error","key",b"key","time",b"time","type",b"type"]) -> None: ...
global___ConfigletAssignmentConfigDeleteAllResponse = ConfigletAssignmentConfigDeleteAllResponse

class ConfigletConfigRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.configlet.v1.configlet_pb2.ConfigletKey:
        """Key uniquely identifies a ConfigletConfig instance to retrieve.
        This value must be populated.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """
        pass
    def __init__(self,
        *,
        key: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletKey] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["key",b"key","time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["key",b"key","time",b"time"]) -> None: ...
global___ConfigletConfigRequest = ConfigletConfigRequest

class ConfigletConfigResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.configlet.v1.configlet_pb2.ConfigletConfig:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        ConfigletConfig instance in this response.
        """
        pass
    def __init__(self,
        *,
        value: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletConfig] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["time",b"time","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["time",b"time","value",b"value"]) -> None: ...
global___ConfigletConfigResponse = ConfigletConfigResponse

class ConfigletConfigSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEYS_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.ConfigletKey]: ...
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """
        pass
    def __init__(self,
        *,
        keys: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.ConfigletKey]] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["keys",b"keys","time",b"time"]) -> None: ...
global___ConfigletConfigSomeRequest = ConfigletConfigSomeRequest

class ConfigletConfigSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.configlet.v1.configlet_pb2.ConfigletConfig:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """
        pass
    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """Error is an optional field.
        It should be filled when there is an error in the GetSome process.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp: ...
    def __init__(self,
        *,
        value: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletConfig] = ...,
        error: typing.Optional[google.protobuf.wrappers_pb2.StringValue] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["error",b"error","time",b"time","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["error",b"error","time",b"time","value",b"value"]) -> None: ...
global___ConfigletConfigSomeResponse = ConfigletConfigSomeResponse

class ConfigletConfigStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.ConfigletConfig]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """
        pass
    @property
    def filter(self) -> arista.configlet.v1.configlet_pb2.Filter:
        """For each ConfigletConfig in the list, all populated fields are considered ANDed together
        as a filtering operation. Similarly, the list itself is ORed such that any individual
        filter that matches a given ConfigletConfig is streamed to the user.
        """
        pass
    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each ConfigletConfig at end.
            * Each ConfigletConfig response is fully-specified (all fields set).
          * start: Returns the state of each ConfigletConfig at start, followed by updates until now.
            * Each ConfigletConfig response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each ConfigletConfig at start, followed by updates
            until end.
            * Each ConfigletConfig response at start is fully-specified, but updates until end may
              be partial.

        This field is not allowed in the Subscribe RPC.
        """
        pass
    def __init__(self,
        *,
        partial_eq_filter: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.ConfigletConfig]] = ...,
        filter: typing.Optional[arista.configlet.v1.configlet_pb2.Filter] = ...,
        time: typing.Optional[arista.time.time_pb2.TimeBounds] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["filter",b"filter","time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["filter",b"filter","partial_eq_filter",b"partial_eq_filter","time",b"time"]) -> None: ...
global___ConfigletConfigStreamRequest = ConfigletConfigStreamRequest

class ConfigletConfigStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.configlet.v1.configlet_pb2.ConfigletConfig:
        """Value is a value deemed relevant to the initiating request.
        This structure will always have its key-field populated. Which other fields are
        populated, and why, depends on the value of Operation and what triggered this notification.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time holds the timestamp of this ConfigletConfig's last modification."""
        pass
    type: arista.subscriptions.subscriptions_pb2.Operation.ValueType
    """Operation indicates how the ConfigletConfig value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """

    def __init__(self,
        *,
        value: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletConfig] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        type: arista.subscriptions.subscriptions_pb2.Operation.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["time",b"time","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["time",b"time","type",b"type","value",b"value"]) -> None: ...
global___ConfigletConfigStreamResponse = ConfigletConfigStreamResponse

class ConfigletConfigBatchedStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    MAX_MESSAGES_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.ConfigletConfig]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """
        pass
    @property
    def filter(self) -> arista.configlet.v1.configlet_pb2.Filter:
        """For each ConfigletConfig in the list, all populated fields are considered ANDed together
        as a filtering operation. Similarly, the list itself is ORed such that any individual
        filter that matches a given ConfigletConfig is streamed to the user.
        """
        pass
    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each ConfigletConfig at end.
            * Each ConfigletConfig response is fully-specified (all fields set).
          * start: Returns the state of each ConfigletConfig at start, followed by updates until now.
            * Each ConfigletConfig response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each ConfigletConfig at start, followed by updates
            until end.
            * Each ConfigletConfig response at start is fully-specified, but updates until end may
              be partial.

        This field is not allowed in the Subscribe RPC.
        """
        pass
    @property
    def max_messages(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """MaxMessages limits the maximum number of messages that can be contained in one batch.
        MaxMessages is required to be at least 1.
        The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
        INTERNAL_BATCH_LIMIT is set based on the maximum message size.
        """
        pass
    def __init__(self,
        *,
        partial_eq_filter: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.ConfigletConfig]] = ...,
        filter: typing.Optional[arista.configlet.v1.configlet_pb2.Filter] = ...,
        time: typing.Optional[arista.time.time_pb2.TimeBounds] = ...,
        max_messages: typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["filter",b"filter","max_messages",b"max_messages","time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["filter",b"filter","max_messages",b"max_messages","partial_eq_filter",b"partial_eq_filter","time",b"time"]) -> None: ...
global___ConfigletConfigBatchedStreamRequest = ConfigletConfigBatchedStreamRequest

class ConfigletConfigBatchedStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    RESPONSES_FIELD_NUMBER: builtins.int
    @property
    def responses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ConfigletConfigStreamResponse]:
        """Values are the values deemed relevant to the initiating request.
        The length of this structure is guaranteed to be between (inclusive) 1 and 
        min(req.max_messages, INTERNAL_BATCH_LIMIT).
        """
        pass
    def __init__(self,
        *,
        responses: typing.Optional[typing.Iterable[global___ConfigletConfigStreamResponse]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["responses",b"responses"]) -> None: ...
global___ConfigletConfigBatchedStreamResponse = ConfigletConfigBatchedStreamResponse

class ConfigletConfigSetRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUE_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.configlet.v1.configlet_pb2.ConfigletConfig:
        """ConfigletConfig carries the value to set into the datastore.
        See the documentation on the ConfigletConfig struct for which fields are required.
        """
        pass
    def __init__(self,
        *,
        value: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletConfig] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["value",b"value"]) -> None: ...
global___ConfigletConfigSetRequest = ConfigletConfigSetRequest

class ConfigletConfigSetResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.configlet.v1.configlet_pb2.ConfigletConfig:
        """Value carries all the values given in the ConfigletConfigSetRequest as well
        as any server-generated values.
        """
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp at which the system recognizes the
        creation. The only guarantees made about this timestamp are:

           - it is after the time the request was received
           - a time-ranged query with StartTime==CreatedAt will include this instance.
        """
        pass
    def __init__(self,
        *,
        value: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletConfig] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["time",b"time","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["time",b"time","value",b"value"]) -> None: ...
global___ConfigletConfigSetResponse = ConfigletConfigSetResponse

class ConfigletConfigSetSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUES_FIELD_NUMBER: builtins.int
    @property
    def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.ConfigletConfig]:
        """value contains a list of ConfigletConfig values to write.
        It is possible to provide more values than can fit within either:
            - the maxiumum send size of the client
            - the maximum receive size of the server
        If this error occurs you must reduce the number of values sent.
        See gRPC "maximum message size" documentation for more information.
        """
        pass
    def __init__(self,
        *,
        values: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.ConfigletConfig]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["values",b"values"]) -> None: ...
global___ConfigletConfigSetSomeRequest = ConfigletConfigSetSomeRequest

class ConfigletConfigSetSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEY_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.configlet.v1.configlet_pb2.ConfigletKey: ...
    error: typing.Text
    def __init__(self,
        *,
        key: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletKey] = ...,
        error: typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["key",b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["error",b"error","key",b"key"]) -> None: ...
global___ConfigletConfigSetSomeResponse = ConfigletConfigSetSomeResponse

class ConfigletConfigDeleteRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEY_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.configlet.v1.configlet_pb2.ConfigletKey:
        """Key indicates which ConfigletConfig instance to remove.
        This field must always be set.
        """
        pass
    def __init__(self,
        *,
        key: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletKey] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["key",b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["key",b"key"]) -> None: ...
global___ConfigletConfigDeleteRequest = ConfigletConfigDeleteRequest

class ConfigletConfigDeleteResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.configlet.v1.configlet_pb2.ConfigletKey:
        """Key echoes back the key of the deleted ConfigletConfig instance."""
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp at which the system recognizes the
        deletion. The only guarantees made about this timestamp are:

           - it is after the time the request was received
           - a time-ranged query with StartTime==DeletedAt will not include this instance.
        """
        pass
    def __init__(self,
        *,
        key: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletKey] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["key",b"key","time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["key",b"key","time",b"time"]) -> None: ...
global___ConfigletConfigDeleteResponse = ConfigletConfigDeleteResponse

class ConfigletConfigDeleteSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEYS_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.ConfigletKey]:
        """key contains a list of ConfigletConfig keys to delete"""
        pass
    def __init__(self,
        *,
        keys: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.ConfigletKey]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["keys",b"keys"]) -> None: ...
global___ConfigletConfigDeleteSomeRequest = ConfigletConfigDeleteSomeRequest

class ConfigletConfigDeleteSomeResponse(google.protobuf.message.Message):
    """ConfigletConfigDeleteSomeResponse is only sent when there is an error."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEY_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.configlet.v1.configlet_pb2.ConfigletKey: ...
    error: typing.Text
    def __init__(self,
        *,
        key: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletKey] = ...,
        error: typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["key",b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["error",b"error","key",b"key"]) -> None: ...
global___ConfigletConfigDeleteSomeResponse = ConfigletConfigDeleteSomeResponse

class ConfigletConfigDeleteAllRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.configlet.v1.configlet_pb2.ConfigletConfig]:
        """PartialEqFilter provides a way to server-side filter a DeleteAll.
        This requires all provided fields to be equal to the response.
        A filtered DeleteAll will use GetAll with filter to find things to delete.
        """
        pass
    @property
    def filter(self) -> arista.configlet.v1.configlet_pb2.Filter:
        """For each ConfigletConfig in the list, all populated fields are considered ANDed together
        as a filtering operation. Similarly, the list itself is ORed such that any individual
        filter that matches a given ConfigletConfig will be deleted.
        """
        pass
    def __init__(self,
        *,
        partial_eq_filter: typing.Optional[typing.Iterable[arista.configlet.v1.configlet_pb2.ConfigletConfig]] = ...,
        filter: typing.Optional[arista.configlet.v1.configlet_pb2.Filter] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["filter",b"filter"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["filter",b"filter","partial_eq_filter",b"partial_eq_filter"]) -> None: ...
global___ConfigletConfigDeleteAllRequest = ConfigletConfigDeleteAllRequest

class ConfigletConfigDeleteAllResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    TYPE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    type: fmp.deletes_pb2.DeleteError.ValueType
    """This describes the class of delete error.
    A DeleteAllResponse is only sent when there is an error.
    """

    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """This indicates the error message from the delete failure."""
        pass
    @property
    def key(self) -> arista.configlet.v1.configlet_pb2.ConfigletKey:
        """This is the key of the ConfigletConfig instance that failed to be deleted."""
        pass
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp when the key was being deleted."""
        pass
    def __init__(self,
        *,
        type: fmp.deletes_pb2.DeleteError.ValueType = ...,
        error: typing.Optional[google.protobuf.wrappers_pb2.StringValue] = ...,
        key: typing.Optional[arista.configlet.v1.configlet_pb2.ConfigletKey] = ...,
        time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["error",b"error","key",b"key","time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["error",b"error","key",b"key","time",b"time","type",b"type"]) -> None: ...
global___ConfigletConfigDeleteAllResponse = ConfigletConfigDeleteAllResponse
