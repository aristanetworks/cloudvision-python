# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
import grpc

from google.protobuf import empty_pb2 as google_dot_protobuf_dot_empty__pb2
import notification_pb2 as notification__pb2
import router_pb2 as router__pb2


class RouterV1Stub(object):
  # missing associated documentation comment in .proto file
  pass

  def __init__(self, channel):
    """Constructor.

    Args:
      channel: A grpc.Channel.
    """
    self.Publish = channel.unary_unary(
        '/RouterV1/Publish',
        request_serializer=router__pb2.PublishRequest.SerializeToString,
        response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
        )
    self.Subscribe = channel.unary_stream(
        '/RouterV1/Subscribe',
        request_serializer=router__pb2.SubscribeRequest.SerializeToString,
        response_deserializer=notification__pb2.NotificationBatch.FromString,
        )
    self.Get = channel.unary_stream(
        '/RouterV1/Get',
        request_serializer=router__pb2.GetRequest.SerializeToString,
        response_deserializer=notification__pb2.NotificationBatch.FromString,
        )
    self.GetAndSubscribe = channel.unary_stream(
        '/RouterV1/GetAndSubscribe',
        request_serializer=router__pb2.GetAndSubscribeRequest.SerializeToString,
        response_deserializer=notification__pb2.NotificationBatch.FromString,
        )
    self.GetDatasets = channel.unary_stream(
        '/RouterV1/GetDatasets',
        request_serializer=router__pb2.DatasetsRequest.SerializeToString,
        response_deserializer=router__pb2.DatasetsResponse.FromString,
        )


class RouterV1Servicer(object):
  # missing associated documentation comment in .proto file
  pass

  def Publish(self, request, context):
    """Publish is used to send notifications to CloudVision.
    They will be saved into the storage and sent to all
    the clients subscribing to the same device/path.

    * Publish guarantees atomicity of the data saved per {timestamp+path+key}.
    For Notification => For one Notification having multiple keys,
    each key is ensured to be saved atomically
    but atomicity is not guaranteed for the entire notification.
    For NotificationBatch =>  if Notif[1] and Notif[5]
    both have updates for a {timestamp+path+key}
    either the update of Notif[1] will be saved, or the update of Notif[5] will be saved.
    The value will be one or the other, not a corrupted combination of both requests.

    * There is no guarantee for write order within a single publish request.
    When sending multiple notifications where multiple notification will have
    the same timestamp, path and keys,
    Publish does not guarantee that Notif[1] will be processed before Notif[5]
    This means that for two notifications in the same Publish call having the
    same {timestamp+path+key}, the result is undefined and will randomly vary
    (i.e. the first notif data will be saved, or the second one).
    The client must send two synchronous Publish requests to guarantee
    the write order at which the requests are processed.

    * Publish is asynchronous by default:
    When the call to Publish ends without error, it means the data has been
    correctly received by CloudVision but not stored yet.
    So, if a "get" call is done right after the Publish call, the get might
    not return the data just published.
    When the "sync" field is set to true in PublishRequest, the Publish
    will be synchronous:
    When the call to Publish ends without error, it means the data has been
    correctly received AND stored by CloudVision.
    So, if a "get" call is done right after the synchronous Publish call, the get will
    return the data just published (unless someone else stored more recent data of course).

    * Client-side and Server-side timestamping:
    The notification object has a timestamp that can be populated by the client.
    In case the Client sends a notification with a "null" timestamp as the
    Notification.timestamp field, the server will populate the timestamp with
    the current time of the node with the server process is running.
    This "current time" will be queried once at the beginning of the Publish request
    and will be used as the Notification.timestamp for all the notification having this field
    as null.
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')

  def Subscribe(self, request, context):
    """Subscribe allows the client to request a live stream of updates
    (V1: either based on regexp or exact match, V2: based on exact match)

    There is no order guarantee for batches received by subscribers.
    It means that two batches A and B published synchronously (B is published after A)
    the subscribers can receive batch A first or B second, OR batch B first and A second.
    This is also true for notifications within a batch.
    The backend can decide to split a batch and reorder notifications so subscribers
    might receive notifications within a batch in a different order that they were published.
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')

  def Get(self, request, context):
    """Get is used to request notifications for a given path over a specified time range.
    Wildcards are supported with Get requests, but when given a range of time the server
    will resolve all wildcard paths at the starting timestamp of the given range, so any
    pointers and/or paths that are created after the given start timestamp will not be
    accounted for during wildcard resolution.
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')

  def GetAndSubscribe(self, request, context):
    """GetAndSubscribe allows the client to issue one request to do both Get and Subscribe requests.
    The server will first send a mix of subscribe and get batches, and there's no distinction
    between which batches are subscribe or get batches. Then the server will send a sync signal
    signaling that the Get stream has finished. After that, server will stream out only subscribe
    batches. There's no order guarantee for batches received by client.
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')

  def GetDatasets(self, request, context):
    # missing associated documentation comment in .proto file
    pass
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')


def add_RouterV1Servicer_to_server(servicer, server):
  rpc_method_handlers = {
      'Publish': grpc.unary_unary_rpc_method_handler(
          servicer.Publish,
          request_deserializer=router__pb2.PublishRequest.FromString,
          response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
      ),
      'Subscribe': grpc.unary_stream_rpc_method_handler(
          servicer.Subscribe,
          request_deserializer=router__pb2.SubscribeRequest.FromString,
          response_serializer=notification__pb2.NotificationBatch.SerializeToString,
      ),
      'Get': grpc.unary_stream_rpc_method_handler(
          servicer.Get,
          request_deserializer=router__pb2.GetRequest.FromString,
          response_serializer=notification__pb2.NotificationBatch.SerializeToString,
      ),
      'GetAndSubscribe': grpc.unary_stream_rpc_method_handler(
          servicer.GetAndSubscribe,
          request_deserializer=router__pb2.GetAndSubscribeRequest.FromString,
          response_serializer=notification__pb2.NotificationBatch.SerializeToString,
      ),
      'GetDatasets': grpc.unary_stream_rpc_method_handler(
          servicer.GetDatasets,
          request_deserializer=router__pb2.DatasetsRequest.FromString,
          response_serializer=router__pb2.DatasetsResponse.SerializeToString,
      ),
  }
  generic_handler = grpc.method_handlers_generic_handler(
      'RouterV1', rpc_method_handlers)
  server.add_generic_rpc_handlers((generic_handler,))


class AuthStub(object):
  # missing associated documentation comment in .proto file
  pass

  def __init__(self, channel):
    """Constructor.

    Args:
      channel: A grpc.Channel.
    """
    self.CreateDataset = channel.unary_unary(
        '/Auth/CreateDataset',
        request_serializer=router__pb2.CreateDatasetRequest.SerializeToString,
        response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
        )
    self.SetPermission = channel.unary_unary(
        '/Auth/SetPermission',
        request_serializer=router__pb2.SetPermissionRequest.SerializeToString,
        response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
        )
    self.GetPermissionSet = channel.unary_stream(
        '/Auth/GetPermissionSet',
        request_serializer=router__pb2.GetRequest.SerializeToString,
        response_deserializer=router__pb2.PermissionSet.FromString,
        )
    self.SetPassword = channel.unary_unary(
        '/Auth/SetPassword',
        request_serializer=router__pb2.SetPasswordRequest.SerializeToString,
        response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
        )
    self.CreateSession = channel.unary_stream(
        '/Auth/CreateSession',
        request_serializer=router__pb2.CreateSessionRequest.SerializeToString,
        response_deserializer=router__pb2.CreateSessionResponse.FromString,
        )


class AuthServicer(object):
  # missing associated documentation comment in .proto file
  pass

  def CreateDataset(self, request, context):
    """CreateDataset from a given Dataset wrapped in a CreateDatasetRequest
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')

  def SetPermission(self, request, context):
    """SetPermission sets a permission for a dataset using a SetPermissionRequest.
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')

  def GetPermissionSet(self, request, context):
    """GetPermissionSet returns the set of all permissions present for the datasets specified
    in the 'query'(s) of the GetRequest.
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')

  def SetPassword(self, request, context):
    """SetPassword sets the password for a user.
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')

  def CreateSession(self, request, context):
    """CreateSession creates session for user
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')


def add_AuthServicer_to_server(servicer, server):
  rpc_method_handlers = {
      'CreateDataset': grpc.unary_unary_rpc_method_handler(
          servicer.CreateDataset,
          request_deserializer=router__pb2.CreateDatasetRequest.FromString,
          response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
      ),
      'SetPermission': grpc.unary_unary_rpc_method_handler(
          servicer.SetPermission,
          request_deserializer=router__pb2.SetPermissionRequest.FromString,
          response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
      ),
      'GetPermissionSet': grpc.unary_stream_rpc_method_handler(
          servicer.GetPermissionSet,
          request_deserializer=router__pb2.GetRequest.FromString,
          response_serializer=router__pb2.PermissionSet.SerializeToString,
      ),
      'SetPassword': grpc.unary_unary_rpc_method_handler(
          servicer.SetPassword,
          request_deserializer=router__pb2.SetPasswordRequest.FromString,
          response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
      ),
      'CreateSession': grpc.unary_stream_rpc_method_handler(
          servicer.CreateSession,
          request_deserializer=router__pb2.CreateSessionRequest.FromString,
          response_serializer=router__pb2.CreateSessionResponse.SerializeToString,
      ),
  }
  generic_handler = grpc.method_handlers_generic_handler(
      'Auth', rpc_method_handlers)
  server.add_generic_rpc_handlers((generic_handler,))


class AlphaStub(object):
  """Alpha services are services which are not supported and
  can be added/removed/changed anytime, without notice.
  Clients should not user them and build applications on top of this service
  """

  def __init__(self, channel):
    """Constructor.

    Args:
      channel: A grpc.Channel.
    """
    self.Search = channel.unary_stream(
        '/Alpha/Search',
        request_serializer=router__pb2.SearchRequest.SerializeToString,
        response_deserializer=notification__pb2.NotificationBatch.FromString,
        )
    self.SearchSubscribe = channel.unary_stream(
        '/Alpha/SearchSubscribe',
        request_serializer=router__pb2.SearchRequest.SerializeToString,
        response_deserializer=notification__pb2.NotificationBatch.FromString,
        )


class AlphaServicer(object):
  """Alpha services are services which are not supported and
  can be added/removed/changed anytime, without notice.
  Clients should not user them and build applications on top of this service
  """

  def Search(self, request, context):
    """you know, for search...
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')

  def SearchSubscribe(self, request, context):
    """SearchSubscribe allows the client to request a live stream of updates
    based on client search request
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')


def add_AlphaServicer_to_server(servicer, server):
  rpc_method_handlers = {
      'Search': grpc.unary_stream_rpc_method_handler(
          servicer.Search,
          request_deserializer=router__pb2.SearchRequest.FromString,
          response_serializer=notification__pb2.NotificationBatch.SerializeToString,
      ),
      'SearchSubscribe': grpc.unary_stream_rpc_method_handler(
          servicer.SearchSubscribe,
          request_deserializer=router__pb2.SearchRequest.FromString,
          response_serializer=notification__pb2.NotificationBatch.SerializeToString,
      ),
  }
  generic_handler = grpc.method_handlers_generic_handler(
      'Alpha', rpc_method_handlers)
  server.add_generic_rpc_handlers((generic_handler,))


class ClusterStub(object):
  """Cluster service gives some descriptions about the cluster where the service
  is running.
  """

  def __init__(self, channel):
    """Constructor.

    Args:
      channel: A grpc.Channel.
    """
    self.ClusterInfo = channel.unary_stream(
        '/Cluster/ClusterInfo',
        request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
        response_deserializer=router__pb2.ClusterDescription.FromString,
        )


class ClusterServicer(object):
  """Cluster service gives some descriptions about the cluster where the service
  is running.
  """

  def ClusterInfo(self, request, context):
    # missing associated documentation comment in .proto file
    pass
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')


def add_ClusterServicer_to_server(servicer, server):
  rpc_method_handlers = {
      'ClusterInfo': grpc.unary_stream_rpc_method_handler(
          servicer.ClusterInfo,
          request_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
          response_serializer=router__pb2.ClusterDescription.SerializeToString,
      ),
  }
  generic_handler = grpc.method_handlers_generic_handler(
      'Cluster', rpc_method_handlers)
  server.add_generic_rpc_handlers((generic_handler,))
