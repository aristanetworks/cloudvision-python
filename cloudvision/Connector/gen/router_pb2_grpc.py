# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from google.protobuf import empty_pb2 as google_dot_protobuf_dot_empty__pb2
import notification_pb2 as notification__pb2
import router_pb2 as router__pb2


class RouterV1Stub(object):
    """Missing associated documentation comment in .proto file."""

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.Publish = channel.unary_unary(
                '/RouterV1/Publish',
                request_serializer=router__pb2.PublishRequest.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                )
        self.Subscribe = channel.unary_stream(
                '/RouterV1/Subscribe',
                request_serializer=router__pb2.SubscribeRequest.SerializeToString,
                response_deserializer=notification__pb2.NotificationBatch.FromString,
                )
        self.Get = channel.unary_stream(
                '/RouterV1/Get',
                request_serializer=router__pb2.GetRequest.SerializeToString,
                response_deserializer=notification__pb2.NotificationBatch.FromString,
                )
        self.GetAndSubscribe = channel.unary_stream(
                '/RouterV1/GetAndSubscribe',
                request_serializer=router__pb2.GetAndSubscribeRequest.SerializeToString,
                response_deserializer=notification__pb2.NotificationBatch.FromString,
                )
        self.GetDatasets = channel.unary_stream(
                '/RouterV1/GetDatasets',
                request_serializer=router__pb2.DatasetsRequest.SerializeToString,
                response_deserializer=router__pb2.DatasetsResponse.FromString,
                )


class RouterV1Servicer(object):
    """Missing associated documentation comment in .proto file."""

    def Publish(self, request, context):
        """Publish is used to send notifications to Cloudvision.
        They will be saved into the storage and sent to all
        the clients subscribing to the same device/path.

        * Publish guarantees atomicity of the data saved per {timestamp+path+key}.
        For Notification => For one Notification having multiple keys,
        each key is ensured to be saved atomically
        but atomicity is not guaranteed for the entire notification.
        For NotificationBatch =>  if Notif[1] and Notif[5]
        both have updates for a {timestamp+path+key}
        either the update of Notif[1] will be saved, or the update of Notif[5] will be saved.
        The value will be one or the other, not a corrupted combination of both requests.

        * There is no guarantee for write order within a single publish request.
        When sending multiple notifications where multiple notification will have
        the same timestamp, path and keys,
        Publish does not guarantee that Notif[1] will be processed before Notif[5]
        This means that for two notifications in the same Publish call having the
        same {timestamp+path+key}, the result is undefined and will randomly vary
        (i.e. the first notif data will be saved, or the second one).
        The client must send two synchronous Publish requests to guarantee
        the write order at which the requests are processed.

        * Publish is asynchronous by default:
        When the call to Publish ends without error, it means the data has been
        correctly received by Cloudvision but not stored yet.
        So, if a "get" call is done right after the Publish call, the get might
        not return the data just published.
        When the "sync" field is set to true in PublishRequest, the Publish
        will be synchronous:
        When the call to Publish ends without error, it means the data has been
        correctly received AND stored by Cloudvision.
        So, if a "get" call is done right after the synchronous Publish call, the get will
        return the data just published (unless someone else stored more recent data of course).

        * Client-side and Server-side timestamping:
        The notification object has a timestamp that can be populated by the client.
        In case the Client sends a notification with a "null" timestamp as the
        Notification.timestamp field, the server will populate the timestamp with
        the current time of the node with the server process is running.
        This "current time" will be queried once at the beginning of the Publish request
        and will be used as the Notification.timestamp for all the notification having this field
        as null.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Subscribe(self, request, context):
        """Subscribe allows the client to request a live stream of updates
        (V1: either based on regexp or exact match, V2: based on exact match)

        There is no order guarantee for batches received by subscribers.
        It means that two batches A and B published synchronously (B is published after A)
        the subscribers can receive batch A first or B second, OR batch B first and A second.
        This is also true for notifications within a batch.
        The backend can decide to split a batch and reorder notifications so subscribers
        might receive notifications within a batch in a different order that they were published.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Get(self, request, context):
        """Get is used to request notifications for a given path over a specified time range.
        Wildcards are supported with Get requests, but when given a range of time the server
        will resolve all wildcard paths at the starting timestamp of the given range, so any
        pointers and/or paths that are created after the given start timestamp will not be
        accounted for during wildcard resolution. The client may receive duplicate notifications.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetAndSubscribe(self, request, context):
        """GetAndSubscribe allows the client to issue one request to do both Get and Subscribe requests.
        The server will first send a mix of subscribe and get batches, and there's no distinction
        between which batches are subscribe or get batches. Then the server will send a sync signal
        signaling that the Get stream has finished. After that, server will stream out only subscribe
        batches. There's no order guarantee for batches received by client.
        The end of get stream sync signal will be in the Metadata field in the NotificationBatch, as
        1 key, value pair: [GetRequest:EOF]. If there are batches returned from Get request, this
        metadata will be in the last Get batch; if there's no results from Get, it will be sent
        in an empty NotificationBatch with only the Metadata field.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetDatasets(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_RouterV1Servicer_to_server(servicer, server):
    rpc_method_handlers = {
            'Publish': grpc.unary_unary_rpc_method_handler(
                    servicer.Publish,
                    request_deserializer=router__pb2.PublishRequest.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
            'Subscribe': grpc.unary_stream_rpc_method_handler(
                    servicer.Subscribe,
                    request_deserializer=router__pb2.SubscribeRequest.FromString,
                    response_serializer=notification__pb2.NotificationBatch.SerializeToString,
            ),
            'Get': grpc.unary_stream_rpc_method_handler(
                    servicer.Get,
                    request_deserializer=router__pb2.GetRequest.FromString,
                    response_serializer=notification__pb2.NotificationBatch.SerializeToString,
            ),
            'GetAndSubscribe': grpc.unary_stream_rpc_method_handler(
                    servicer.GetAndSubscribe,
                    request_deserializer=router__pb2.GetAndSubscribeRequest.FromString,
                    response_serializer=notification__pb2.NotificationBatch.SerializeToString,
            ),
            'GetDatasets': grpc.unary_stream_rpc_method_handler(
                    servicer.GetDatasets,
                    request_deserializer=router__pb2.DatasetsRequest.FromString,
                    response_serializer=router__pb2.DatasetsResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'RouterV1', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class RouterV1(object):
    """Missing associated documentation comment in .proto file."""

    @staticmethod
    def Publish(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/RouterV1/Publish',
            router__pb2.PublishRequest.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def Subscribe(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/RouterV1/Subscribe',
            router__pb2.SubscribeRequest.SerializeToString,
            notification__pb2.NotificationBatch.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def Get(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/RouterV1/Get',
            router__pb2.GetRequest.SerializeToString,
            notification__pb2.NotificationBatch.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def GetAndSubscribe(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/RouterV1/GetAndSubscribe',
            router__pb2.GetAndSubscribeRequest.SerializeToString,
            notification__pb2.NotificationBatch.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def GetDatasets(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/RouterV1/GetDatasets',
            router__pb2.DatasetsRequest.SerializeToString,
            router__pb2.DatasetsResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)


class AuthStub(object):
    """Missing associated documentation comment in .proto file."""

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.CreateDataset = channel.unary_unary(
                '/Auth/CreateDataset',
                request_serializer=router__pb2.CreateDatasetRequest.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                )
        self.SetPermission = channel.unary_unary(
                '/Auth/SetPermission',
                request_serializer=router__pb2.SetPermissionRequest.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                )
        self.GetPermissionSet = channel.unary_stream(
                '/Auth/GetPermissionSet',
                request_serializer=router__pb2.GetRequest.SerializeToString,
                response_deserializer=router__pb2.PermissionSet.FromString,
                )
        self.SetPassword = channel.unary_unary(
                '/Auth/SetPassword',
                request_serializer=router__pb2.SetPasswordRequest.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                )
        self.CreateSession = channel.unary_stream(
                '/Auth/CreateSession',
                request_serializer=router__pb2.CreateSessionRequest.SerializeToString,
                response_deserializer=router__pb2.CreateSessionResponse.FromString,
                )


class AuthServicer(object):
    """Missing associated documentation comment in .proto file."""

    def CreateDataset(self, request, context):
        """CreateDataset from a given Dataset wrapped in a CreateDatasetRequest
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SetPermission(self, request, context):
        """SetPermission sets a permission for a dataset using a SetPermissionRequest.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetPermissionSet(self, request, context):
        """GetPermissionSet returns the set of all permissions present for the datasets specified
        in the 'query'(s) of the GetRequest.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SetPassword(self, request, context):
        """SetPassword sets the password for a user.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def CreateSession(self, request, context):
        """CreateSession creates session for user
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_AuthServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'CreateDataset': grpc.unary_unary_rpc_method_handler(
                    servicer.CreateDataset,
                    request_deserializer=router__pb2.CreateDatasetRequest.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
            'SetPermission': grpc.unary_unary_rpc_method_handler(
                    servicer.SetPermission,
                    request_deserializer=router__pb2.SetPermissionRequest.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
            'GetPermissionSet': grpc.unary_stream_rpc_method_handler(
                    servicer.GetPermissionSet,
                    request_deserializer=router__pb2.GetRequest.FromString,
                    response_serializer=router__pb2.PermissionSet.SerializeToString,
            ),
            'SetPassword': grpc.unary_unary_rpc_method_handler(
                    servicer.SetPassword,
                    request_deserializer=router__pb2.SetPasswordRequest.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
            'CreateSession': grpc.unary_stream_rpc_method_handler(
                    servicer.CreateSession,
                    request_deserializer=router__pb2.CreateSessionRequest.FromString,
                    response_serializer=router__pb2.CreateSessionResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'Auth', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class Auth(object):
    """Missing associated documentation comment in .proto file."""

    @staticmethod
    def CreateDataset(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/Auth/CreateDataset',
            router__pb2.CreateDatasetRequest.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def SetPermission(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/Auth/SetPermission',
            router__pb2.SetPermissionRequest.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def GetPermissionSet(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/Auth/GetPermissionSet',
            router__pb2.GetRequest.SerializeToString,
            router__pb2.PermissionSet.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def SetPassword(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/Auth/SetPassword',
            router__pb2.SetPasswordRequest.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def CreateSession(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/Auth/CreateSession',
            router__pb2.CreateSessionRequest.SerializeToString,
            router__pb2.CreateSessionResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)


class SearchStub(object):
    """Search provides methods to query CloudVision using the Search service.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.Search = channel.unary_stream(
                '/Search/Search',
                request_serializer=router__pb2.SearchRequest.SerializeToString,
                response_deserializer=notification__pb2.NotificationBatch.FromString,
                )
        self.SearchSubscribe = channel.unary_stream(
                '/Search/SearchSubscribe',
                request_serializer=router__pb2.SearchRequest.SerializeToString,
                response_deserializer=notification__pb2.NotificationBatch.FromString,
                )
        self.SearchWithAggregation = channel.unary_unary(
                '/Search/SearchWithAggregation',
                request_serializer=router__pb2.SearchRequestWithAggr.SerializeToString,
                response_deserializer=router__pb2.AggrResponse.FromString,
                )
        self.SearchWithAggregationStream = channel.unary_stream(
                '/Search/SearchWithAggregationStream',
                request_serializer=router__pb2.SearchRequestWithAggr.SerializeToString,
                response_deserializer=router__pb2.ByteStream.FromString,
                )
        self.SetCustomSchema = channel.unary_unary(
                '/Search/SetCustomSchema',
                request_serializer=router__pb2.CustomIndexSchema.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                )
        self.DeleteCustomSchema = channel.unary_unary(
                '/Search/DeleteCustomSchema',
                request_serializer=router__pb2.CustomIndexSchemaDel.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                )


class SearchServicer(object):
    """Search provides methods to query CloudVision using the Search service.
    """

    def Search(self, request, context):
        """you know, for search...
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SearchSubscribe(self, request, context):
        """SearchSubscribe allows the client to request a live stream of updates
        based on client search request
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SearchWithAggregation(self, request, context):
        """for search with aggregation
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SearchWithAggregationStream(self, request, context):
        """SearchWithAggregationStream sends the protobuf-serialized form of AggrResponse as in a stream 
        of byteArrays. Receiver needs to append the "bytearrays", and protobuf-deserialize
        to obtain the result. Intended for messages exceeding the grpc size limit
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SetCustomSchema(self, request, context):
        """for custom schema configuration
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def DeleteCustomSchema(self, request, context):
        """for custom schema deletion
        This is alpha version of this api and doesn't synchronize across apiserver instances.
        apiserver restart is needed to get updated schema information from hbase.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_SearchServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'Search': grpc.unary_stream_rpc_method_handler(
                    servicer.Search,
                    request_deserializer=router__pb2.SearchRequest.FromString,
                    response_serializer=notification__pb2.NotificationBatch.SerializeToString,
            ),
            'SearchSubscribe': grpc.unary_stream_rpc_method_handler(
                    servicer.SearchSubscribe,
                    request_deserializer=router__pb2.SearchRequest.FromString,
                    response_serializer=notification__pb2.NotificationBatch.SerializeToString,
            ),
            'SearchWithAggregation': grpc.unary_unary_rpc_method_handler(
                    servicer.SearchWithAggregation,
                    request_deserializer=router__pb2.SearchRequestWithAggr.FromString,
                    response_serializer=router__pb2.AggrResponse.SerializeToString,
            ),
            'SearchWithAggregationStream': grpc.unary_stream_rpc_method_handler(
                    servicer.SearchWithAggregationStream,
                    request_deserializer=router__pb2.SearchRequestWithAggr.FromString,
                    response_serializer=router__pb2.ByteStream.SerializeToString,
            ),
            'SetCustomSchema': grpc.unary_unary_rpc_method_handler(
                    servicer.SetCustomSchema,
                    request_deserializer=router__pb2.CustomIndexSchema.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
            'DeleteCustomSchema': grpc.unary_unary_rpc_method_handler(
                    servicer.DeleteCustomSchema,
                    request_deserializer=router__pb2.CustomIndexSchemaDel.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'Search', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class Search(object):
    """Search provides methods to query CloudVision using the Search service.
    """

    @staticmethod
    def Search(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/Search/Search',
            router__pb2.SearchRequest.SerializeToString,
            notification__pb2.NotificationBatch.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def SearchSubscribe(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/Search/SearchSubscribe',
            router__pb2.SearchRequest.SerializeToString,
            notification__pb2.NotificationBatch.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def SearchWithAggregation(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/Search/SearchWithAggregation',
            router__pb2.SearchRequestWithAggr.SerializeToString,
            router__pb2.AggrResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def SearchWithAggregationStream(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/Search/SearchWithAggregationStream',
            router__pb2.SearchRequestWithAggr.SerializeToString,
            router__pb2.ByteStream.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def SetCustomSchema(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/Search/SetCustomSchema',
            router__pb2.CustomIndexSchema.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def DeleteCustomSchema(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/Search/DeleteCustomSchema',
            router__pb2.CustomIndexSchemaDel.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)


class AlphaStub(object):
    """Alpha services are deprecated. Please use SearchV1
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.Search = channel.unary_stream(
                '/Alpha/Search',
                request_serializer=router__pb2.SearchRequest.SerializeToString,
                response_deserializer=notification__pb2.NotificationBatch.FromString,
                )
        self.SearchSubscribe = channel.unary_stream(
                '/Alpha/SearchSubscribe',
                request_serializer=router__pb2.SearchRequest.SerializeToString,
                response_deserializer=notification__pb2.NotificationBatch.FromString,
                )
        self.SearchWithAggregation = channel.unary_unary(
                '/Alpha/SearchWithAggregation',
                request_serializer=router__pb2.SearchRequestWithAggr.SerializeToString,
                response_deserializer=router__pb2.AggrResponse.FromString,
                )
        self.SearchWithAggregationStream = channel.unary_stream(
                '/Alpha/SearchWithAggregationStream',
                request_serializer=router__pb2.SearchRequestWithAggr.SerializeToString,
                response_deserializer=router__pb2.ByteStream.FromString,
                )
        self.SetCustomSchema = channel.unary_unary(
                '/Alpha/SetCustomSchema',
                request_serializer=router__pb2.CustomIndexSchema.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                )
        self.DeleteCustomSchema = channel.unary_unary(
                '/Alpha/DeleteCustomSchema',
                request_serializer=router__pb2.CustomIndexSchemaDel.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                )


class AlphaServicer(object):
    """Alpha services are deprecated. Please use SearchV1
    """

    def Search(self, request, context):
        """you know, for search...
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SearchSubscribe(self, request, context):
        """SearchSubscribe allows the client to request a live stream of updates
        based on client search request
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SearchWithAggregation(self, request, context):
        """for search with aggregation
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SearchWithAggregationStream(self, request, context):
        """SearchWithAggregationStream sends the protobuf-serialized form of AggrResponse as in a stream 
        of byteArrays. Receiver needs to append the "bytearrays", and protobuf-deserialize
        to obtain the result. Intended for messages exceeding the grpc size limit
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SetCustomSchema(self, request, context):
        """for custom schema configuration
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def DeleteCustomSchema(self, request, context):
        """for custom schema deletion
        This is alpha version of this api and doesn't synchronize across apiserver instances.
        apiserver restart is needed to get updated schema information from hbase.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_AlphaServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'Search': grpc.unary_stream_rpc_method_handler(
                    servicer.Search,
                    request_deserializer=router__pb2.SearchRequest.FromString,
                    response_serializer=notification__pb2.NotificationBatch.SerializeToString,
            ),
            'SearchSubscribe': grpc.unary_stream_rpc_method_handler(
                    servicer.SearchSubscribe,
                    request_deserializer=router__pb2.SearchRequest.FromString,
                    response_serializer=notification__pb2.NotificationBatch.SerializeToString,
            ),
            'SearchWithAggregation': grpc.unary_unary_rpc_method_handler(
                    servicer.SearchWithAggregation,
                    request_deserializer=router__pb2.SearchRequestWithAggr.FromString,
                    response_serializer=router__pb2.AggrResponse.SerializeToString,
            ),
            'SearchWithAggregationStream': grpc.unary_stream_rpc_method_handler(
                    servicer.SearchWithAggregationStream,
                    request_deserializer=router__pb2.SearchRequestWithAggr.FromString,
                    response_serializer=router__pb2.ByteStream.SerializeToString,
            ),
            'SetCustomSchema': grpc.unary_unary_rpc_method_handler(
                    servicer.SetCustomSchema,
                    request_deserializer=router__pb2.CustomIndexSchema.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
            'DeleteCustomSchema': grpc.unary_unary_rpc_method_handler(
                    servicer.DeleteCustomSchema,
                    request_deserializer=router__pb2.CustomIndexSchemaDel.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'Alpha', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class Alpha(object):
    """Alpha services are deprecated. Please use SearchV1
    """

    @staticmethod
    def Search(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/Alpha/Search',
            router__pb2.SearchRequest.SerializeToString,
            notification__pb2.NotificationBatch.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def SearchSubscribe(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/Alpha/SearchSubscribe',
            router__pb2.SearchRequest.SerializeToString,
            notification__pb2.NotificationBatch.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def SearchWithAggregation(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/Alpha/SearchWithAggregation',
            router__pb2.SearchRequestWithAggr.SerializeToString,
            router__pb2.AggrResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def SearchWithAggregationStream(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/Alpha/SearchWithAggregationStream',
            router__pb2.SearchRequestWithAggr.SerializeToString,
            router__pb2.ByteStream.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def SetCustomSchema(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/Alpha/SetCustomSchema',
            router__pb2.CustomIndexSchema.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def DeleteCustomSchema(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/Alpha/DeleteCustomSchema',
            router__pb2.CustomIndexSchemaDel.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)


class QuerierStub(object):
    """Missing associated documentation comment in .proto file."""

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.SQL = channel.unary_stream(
                '/Querier/SQL',
                request_serializer=router__pb2.SQLRequest.SerializeToString,
                response_deserializer=router__pb2.SQLResponse.FromString,
                )


class QuerierServicer(object):
    """Missing associated documentation comment in .proto file."""

    def SQL(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_QuerierServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'SQL': grpc.unary_stream_rpc_method_handler(
                    servicer.SQL,
                    request_deserializer=router__pb2.SQLRequest.FromString,
                    response_serializer=router__pb2.SQLResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'Querier', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class Querier(object):
    """Missing associated documentation comment in .proto file."""

    @staticmethod
    def SQL(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/Querier/SQL',
            router__pb2.SQLRequest.SerializeToString,
            router__pb2.SQLResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)


class ClusterStub(object):
    """Cluster service gives some descriptions about the cluster where the service
    is running.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.ClusterInfo = channel.unary_stream(
                '/Cluster/ClusterInfo',
                request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
                response_deserializer=router__pb2.ClusterDescription.FromString,
                )


class ClusterServicer(object):
    """Cluster service gives some descriptions about the cluster where the service
    is running.
    """

    def ClusterInfo(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_ClusterServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'ClusterInfo': grpc.unary_stream_rpc_method_handler(
                    servicer.ClusterInfo,
                    request_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                    response_serializer=router__pb2.ClusterDescription.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'Cluster', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class Cluster(object):
    """Cluster service gives some descriptions about the cluster where the service
    is running.
    """

    @staticmethod
    def ClusterInfo(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/Cluster/ClusterInfo',
            google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            router__pb2.ClusterDescription.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
