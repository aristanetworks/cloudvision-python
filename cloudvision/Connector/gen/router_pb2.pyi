"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import notification_pb2
import sharding_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _PathWildCardExpandType:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _PathWildCardExpandTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_PathWildCardExpandType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    WILDCARD_EXPAND_LEGACY: _PathWildCardExpandType.ValueType  # 0
    """WILDCARD_EXPAND_LEGACY falls back to default behavior"""

    WILDCARD_EXPAND_LATEST: _PathWildCardExpandType.ValueType  # 1
    """WILDCARD_EXPAND_LATEST means that only latest path pointers will be considered"""

    WILDCARD_EXPAND_EXACT_RANGE: _PathWildCardExpandType.ValueType  # 2
    """WILDCARD_EXPAND_EXACT_RANGE means that path pointers satisfying given start/end will be considered"""

    WILDCARD_EXPAND_RELAXED_RANGE: _PathWildCardExpandType.ValueType  # 3
    """WILDCARD_EXPAND_RELAXED_RANGE means that path pointers satisfying 0 to end will be considered"""

class PathWildCardExpandType(_PathWildCardExpandType, metaclass=_PathWildCardExpandTypeEnumTypeWrapper):
    pass

WILDCARD_EXPAND_LEGACY: PathWildCardExpandType.ValueType  # 0
"""WILDCARD_EXPAND_LEGACY falls back to default behavior"""

WILDCARD_EXPAND_LATEST: PathWildCardExpandType.ValueType  # 1
"""WILDCARD_EXPAND_LATEST means that only latest path pointers will be considered"""

WILDCARD_EXPAND_EXACT_RANGE: PathWildCardExpandType.ValueType  # 2
"""WILDCARD_EXPAND_EXACT_RANGE means that path pointers satisfying given start/end will be considered"""

WILDCARD_EXPAND_RELAXED_RANGE: PathWildCardExpandType.ValueType  # 3
"""WILDCARD_EXPAND_RELAXED_RANGE means that path pointers satisfying 0 to end will be considered"""

global___PathWildCardExpandType = PathWildCardExpandType


class _SortType:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _SortTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SortType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SORT_INVALID: _SortType.ValueType  # 0
    DESC: _SortType.ValueType  # 1
    """Descending order sort"""

    ASC: _SortType.ValueType  # 2
    """Ascending order sort"""

class SortType(_SortType, metaclass=_SortTypeEnumTypeWrapper):
    pass

SORT_INVALID: SortType.ValueType  # 0
DESC: SortType.ValueType  # 1
"""Descending order sort"""

ASC: SortType.ValueType  # 2
"""Ascending order sort"""

global___SortType = SortType


class _IndexDataType:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _IndexDataTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_IndexDataType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    INVALID: _IndexDataType.ValueType  # 0
    INTEGER: _IndexDataType.ValueType  # 1
    FLOAT: _IndexDataType.ValueType  # 2
    STRING: _IndexDataType.ValueType  # 3
    ARRAY: _IndexDataType.ValueType  # 11
    OBJECT: _IndexDataType.ValueType  # 12
class IndexDataType(_IndexDataType, metaclass=_IndexDataTypeEnumTypeWrapper):
    pass

INVALID: IndexDataType.ValueType  # 0
INTEGER: IndexDataType.ValueType  # 1
FLOAT: IndexDataType.ValueType  # 2
STRING: IndexDataType.ValueType  # 3
ARRAY: IndexDataType.ValueType  # 11
OBJECT: IndexDataType.ValueType  # 12
global___IndexDataType = IndexDataType


class Path(google.protobuf.message.Message):
    """Path defines a path matcher for a Query."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Type:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Path._Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        EXACT: Path._Type.ValueType  # 0
        """EXACT means that the "path" will be matched exactly"""

        REGEXP: Path._Type.ValueType  # 1
        """REGEXP means that the "path" will be treated as regexp"""

    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        """V2: DEPRECATED"""
        pass

    EXACT: Path.Type.ValueType  # 0
    """EXACT means that the "path" will be matched exactly"""

    REGEXP: Path.Type.ValueType  # 1
    """REGEXP means that the "path" will be treated as regexp"""


    TYPE_FIELD_NUMBER: builtins.int
    PATH_FIELD_NUMBER: builtins.int
    KEYS_FIELD_NUMBER: builtins.int
    PATH_ELEMENTS_FIELD_NUMBER: builtins.int
    type: global___Path.Type.ValueType
    """V2: DEPRECATED"""

    path: typing.Text
    """V2: DEPRECATED"""

    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bytes]:
        """Keys (V1: BSDN, V2: NEAT) can be optionally provided to narrow the set
        of notification keys included in the result.
        """
        pass
    @property
    def path_elements(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bytes]:
        """PathElements (V2: NEAT) are a list of keys representing a path."""
        pass
    def __init__(self,
        *,
        type: global___Path.Type.ValueType = ...,
        path: typing.Text = ...,
        keys: typing.Optional[typing.Iterable[builtins.bytes]] = ...,
        path_elements: typing.Optional[typing.Iterable[builtins.bytes]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["keys",b"keys","path",b"path","path_elements",b"path_elements","type",b"type"]) -> None: ...
global___Path = Path

class Query(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    DATASET_FIELD_NUMBER: builtins.int
    PATHS_FIELD_NUMBER: builtins.int
    @property
    def dataset(self) -> notification_pb2.Dataset: ...
    @property
    def paths(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Path]: ...
    def __init__(self,
        *,
        dataset: typing.Optional[notification_pb2.Dataset] = ...,
        paths: typing.Optional[typing.Iterable[global___Path]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["dataset",b"dataset"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["dataset",b"dataset","paths",b"paths"]) -> None: ...
global___Query = Query

class SubscribeRequest(google.protobuf.message.Message):
    """SubscribeRequest defines the stream subset the client is subscribing to.

    V1:

    The filtering is done first by dataset:
      - if Query.Dataset.Name == "<name>" and Query.Dataset.Typ == "<type>",
        matching notificaitons from dataset "<type>:<name>" that are returned.
      - if Query.Dataset.Name == "" and Query.Dataset.Typ == "<type>",
        matching notifications from datasets with type "<type>" are returned.
      - if Query.Dataset.Name == "" and Query.Dataset.Typ == "",
        matching notifications from all datasets are returned.
    TODO: for now the above rules only work if Path.regexp_path is specified.
          Path.exact_path expects Query.Dataset.Name and Query.Dataset.Typ to be non-empty
    If a notification matches any of the rules above, next it's matched against Query.Paths.
    The shardedsub field contains the information relative to horizontal scaling
    (number of instances, ID of the subscribing instance, and dispatching method)

    V2:

    If path elements are not provided:

    Uses V1 logic.

    If path elements are provided:

    Notification filtering is done by queries. For each query, the dataset name and
    type must be non-empty. Notifications that match the query paths are streamed to
    the client. The sharded sub field contains information relating to horizontal
    scaling (i.e. number of instances, ID of the subscribing instance, and dispatching
    method).
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    QUERY_FIELD_NUMBER: builtins.int
    SHARDED_SUB_FIELD_NUMBER: builtins.int
    @property
    def query(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Query]: ...
    @property
    def sharded_sub(self) -> sharding_pb2.Sharding: ...
    def __init__(self,
        *,
        query: typing.Optional[typing.Iterable[global___Query]] = ...,
        sharded_sub: typing.Optional[sharding_pb2.Sharding] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["sharded_sub",b"sharded_sub"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["query",b"query","sharded_sub",b"sharded_sub"]) -> None: ...
global___SubscribeRequest = SubscribeRequest

class GetRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    QUERY_FIELD_NUMBER: builtins.int
    START_FIELD_NUMBER: builtins.int
    VERSIONS_FIELD_NUMBER: builtins.int
    END_FIELD_NUMBER: builtins.int
    EXACT_RANGE_FIELD_NUMBER: builtins.int
    SHARDED_SUB_FIELD_NUMBER: builtins.int
    WILDCARD_EXPAND_TYPE_FIELD_NUMBER: builtins.int
    @property
    def query(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Query]:
        """V1:

        NOTE: Query.Path.Type = REGEXP is not supported for GetRequest.
        """
        pass
    start: builtins.int
    """(Optional) Lower bound (inclusive) of time range to retrieve, in nanoseconds since the Epoch.
    If `start` is set, the returned results will correspond to a time range query (from `start` to
    `end` or now, depending on whether `end` is set or not).
    If `start` is not set, this request will execute a "limit" query based on `versions`.
    The value 0 corresponds to an unset field.
    """

    versions: builtins.int
    """(Optional) Maximum number of versions to retrieve.
    If `start` is set, this value is ignored. Otherwise, will return at most (`versions` + 1) past
    versions.
    """

    end: builtins.int
    """(Optional) Upper bound (inclusive) of time range to retrieve, in nanoseconds since the Epoch.
    The value 0 corresponds to an unset field.  Defaults to the largest valid timestamp.
    """

    exact_range: builtins.bool
    """(Optional) Whether to return the initial state of the requested paths at time `start`.
    The "initial state" is the set of notifications that fully specify the state of the path at
    that time. It includes all relevant notifications before (and up to) `start`.
    If `start` is not set, this is ignored.
    """

    @property
    def sharded_sub(self) -> sharding_pb2.Sharding:
        """(Optional) Number of client instances, id of the client making the request, and sharding
        method for the implementation of horizontal scaling. If not set, no filtering will happen.
        """
        pass
    wildcard_expand_type: global___PathWildCardExpandType.ValueType
    """(Optional) Specifies wildcard expansion strategy when time range is specified.
    This option has no effect when time range (start/end) is not used.
    """

    def __init__(self,
        *,
        query: typing.Optional[typing.Iterable[global___Query]] = ...,
        start: builtins.int = ...,
        versions: builtins.int = ...,
        end: builtins.int = ...,
        exact_range: builtins.bool = ...,
        sharded_sub: typing.Optional[sharding_pb2.Sharding] = ...,
        wildcard_expand_type: global___PathWildCardExpandType.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["sharded_sub",b"sharded_sub"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["end",b"end","exact_range",b"exact_range","query",b"query","sharded_sub",b"sharded_sub","start",b"start","versions",b"versions","wildcard_expand_type",b"wildcard_expand_type"]) -> None: ...
global___GetRequest = GetRequest

class GetAndSubscribeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    QUERY_FIELD_NUMBER: builtins.int
    START_FIELD_NUMBER: builtins.int
    VERSIONS_FIELD_NUMBER: builtins.int
    EXACT_RANGE_FIELD_NUMBER: builtins.int
    SHARDED_SUB_FIELD_NUMBER: builtins.int
    WILDCARD_EXPAND_TYPE_FIELD_NUMBER: builtins.int
    @property
    def query(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Query]: ...
    start: builtins.int
    """(Optional) Lower bound (inclusive) of time range to retrieve, in nanoseconds since the Epoch.
    If `start` is set, the returned results will correspond to a time range query (from `start` to
    `end` or now, depending on whether `end` is set or not).
    If `start` is not set, this request will execute a "limit" query based on `versions`.
    The value 0 corresponds to an unset field.
    """

    versions: builtins.int
    """(Optional) Maximum number of versions to retrieve.
    If `start` is set, this value is ignored. Otherwise, will return at most (`versions` + 1) past
    versions.
    """

    exact_range: builtins.bool
    """(Optional) Whether to return the initial state of the requested paths at time `start`.
    The "initial state" is the set of notifications that fully specify the state of the path at
    that time. It includes all relevant notifications before (and up to) `start`.
    If `start` is not set, this is ignored.
    """

    @property
    def sharded_sub(self) -> sharding_pb2.Sharding:
        """(Optional) Number of client instances, id of the client making the request, and sharding
        method for the implementation of horizontal scaling. If not set, no filtering will happen.
        """
        pass
    wildcard_expand_type: global___PathWildCardExpandType.ValueType
    """(Optional) Specifies wildcard expansion strategy when time range is specified.
    This option has no effect when time range (start/end) is not used.
    """

    def __init__(self,
        *,
        query: typing.Optional[typing.Iterable[global___Query]] = ...,
        start: builtins.int = ...,
        versions: builtins.int = ...,
        exact_range: builtins.bool = ...,
        sharded_sub: typing.Optional[sharding_pb2.Sharding] = ...,
        wildcard_expand_type: global___PathWildCardExpandType.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["sharded_sub",b"sharded_sub"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["exact_range",b"exact_range","query",b"query","sharded_sub",b"sharded_sub","start",b"start","versions",b"versions","wildcard_expand_type",b"wildcard_expand_type"]) -> None: ...
global___GetAndSubscribeRequest = GetAndSubscribeRequest

class Sort(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    FIELDS_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    @property
    def fields(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """fields to support nesting. a.b.c needs to specified as ["a","b","c"]."""
        pass
    type: global___SortType.ValueType
    """type of sort"""

    def __init__(self,
        *,
        fields: typing.Optional[typing.Iterable[typing.Text]] = ...,
        type: global___SortType.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["fields",b"fields","type",b"type"]) -> None: ...
global___Sort = Sort

class SearchRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Type:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[SearchRequest._Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STRING: SearchRequest._Type.ValueType  # 0
        """STRING means that Key/Value string fields will be searched"""

        MAC: SearchRequest._Type.ValueType  # 1
        """MAC means that Key/Value mac fields will be searched"""

        IP: SearchRequest._Type.ValueType  # 2
        """IP means that Key/Value ip fields will be searched"""

        COMPLEX: SearchRequest._Type.ValueType  # 3
        """COMPLEX means that a complex key or value will be searched"""

        CUSTOM: SearchRequest._Type.ValueType  # 4
        """CUSTOM means that custom schema is used. Path prefix is mandatory in query."""

    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        pass

    STRING: SearchRequest.Type.ValueType  # 0
    """STRING means that Key/Value string fields will be searched"""

    MAC: SearchRequest.Type.ValueType  # 1
    """MAC means that Key/Value mac fields will be searched"""

    IP: SearchRequest.Type.ValueType  # 2
    """IP means that Key/Value ip fields will be searched"""

    COMPLEX: SearchRequest.Type.ValueType  # 3
    """COMPLEX means that a complex key or value will be searched"""

    CUSTOM: SearchRequest.Type.ValueType  # 4
    """CUSTOM means that custom schema is used. Path prefix is mandatory in query."""


    SEARCH_FIELD_NUMBER: builtins.int
    SEARCH_TYPE_FIELD_NUMBER: builtins.int
    QUERY_FIELD_NUMBER: builtins.int
    START_FIELD_NUMBER: builtins.int
    END_FIELD_NUMBER: builtins.int
    COUNT_ONLY_FIELD_NUMBER: builtins.int
    KEY_FILTERS_FIELD_NUMBER: builtins.int
    VALUE_FILTERS_FIELD_NUMBER: builtins.int
    SORT_FIELD_NUMBER: builtins.int
    EXACT_RANGE_FIELD_NUMBER: builtins.int
    SHARDED_SUB_FIELD_NUMBER: builtins.int
    EXACT_TERM_FIELD_NUMBER: builtins.int
    RESULT_SIZE_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    META_FIELD_NUMBER: builtins.int
    search: typing.Text
    """A search string"""

    search_type: global___SearchRequest.Type.ValueType
    """The type of value that's being searched."""

    @property
    def query(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Query]:
        """Filter on specific datasets and paths."""
        pass
    start: builtins.int
    """Start and end time of the notifications returned, inclusive."""

    end: builtins.int
    count_only: builtins.bool
    """Return only the number of results"""

    @property
    def key_filters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Filter]:
        """Complex fields search
        These are applicable for CUSTOM type as well
        """
        pass
    @property
    def value_filters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Filter]: ...
    @property
    def sort(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Sort]:
        """Sort criteria"""
        pass
    exact_range: builtins.bool
    """(Optional) Whether to return the initial state of the requested paths at time `start`.
    The "initial state" is the set of notifications that fully specify the state of the path at
    that time. It includes all relevant notifications before (and up to) `start`.
    If `start` is not set, this is ignored.
    """

    @property
    def sharded_sub(self) -> sharding_pb2.Sharding:
        """(Optional) Set NumParentShards field >= 1 to enable multi-tenant search"""
        pass
    exact_term: builtins.bool
    """(Optional) whether search exact term or not, useful for string search"""

    result_size: builtins.int
    """For pagination

    Total number of notification to get back in the response
    """

    offset: builtins.int
    """Numeric offset as starting point for next page of result"""

    @property
    def meta(self) -> notification_pb2.NotificationBatch:
        """cursor based pagination"""
        pass
    def __init__(self,
        *,
        search: typing.Text = ...,
        search_type: global___SearchRequest.Type.ValueType = ...,
        query: typing.Optional[typing.Iterable[global___Query]] = ...,
        start: builtins.int = ...,
        end: builtins.int = ...,
        count_only: builtins.bool = ...,
        key_filters: typing.Optional[typing.Iterable[global___Filter]] = ...,
        value_filters: typing.Optional[typing.Iterable[global___Filter]] = ...,
        sort: typing.Optional[typing.Iterable[global___Sort]] = ...,
        exact_range: builtins.bool = ...,
        sharded_sub: typing.Optional[sharding_pb2.Sharding] = ...,
        exact_term: builtins.bool = ...,
        result_size: builtins.int = ...,
        offset: builtins.int = ...,
        meta: typing.Optional[notification_pb2.NotificationBatch] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["meta",b"meta","sharded_sub",b"sharded_sub"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["count_only",b"count_only","end",b"end","exact_range",b"exact_range","exact_term",b"exact_term","key_filters",b"key_filters","meta",b"meta","offset",b"offset","query",b"query","result_size",b"result_size","search",b"search","search_type",b"search_type","sharded_sub",b"sharded_sub","sort",b"sort","start",b"start","value_filters",b"value_filters"]) -> None: ...
global___SearchRequest = SearchRequest

class Filter(google.protobuf.message.Message):
    """field name and filter value"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Operator:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _OperatorEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Filter._Operator.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        EQ: Filter._Operator.ValueType  # 0
        """equal to"""

        NEQ: Filter._Operator.ValueType  # 1
        """not equal to"""

        GT: Filter._Operator.ValueType  # 2
        """greater than"""

        GE: Filter._Operator.ValueType  # 3
        """greater than or equal to"""

        LT: Filter._Operator.ValueType  # 4
        """less than"""

        LE: Filter._Operator.ValueType  # 5
        """less than or equal to"""

        RE: Filter._Operator.ValueType  # 6
        """regex"""

        NRE: Filter._Operator.ValueType  # 7
        """not regex"""

        IN: Filter._Operator.ValueType  # 8
        """in"""

        NIN: Filter._Operator.ValueType  # 9
        """not in"""

        SUB: Filter._Operator.ValueType  # 10
        """substring (prefix substring)"""

        WILDCARD: Filter._Operator.ValueType  # 11
        """wildcard query (for custom index only)"""

        BITMASK: Filter._Operator.ValueType  # 16
        """filter on bitmask bit(s) are set. Only applicable for integer fields"""

        LOGICALOR: Filter._Operator.ValueType  # 20
        """Logical OR operator to be used between two filters"""

        LOGICALAND: Filter._Operator.ValueType  # 21
        """Logical AND operator to be used between two filters"""

    class Operator(_Operator, metaclass=_OperatorEnumTypeWrapper):
        pass

    EQ: Filter.Operator.ValueType  # 0
    """equal to"""

    NEQ: Filter.Operator.ValueType  # 1
    """not equal to"""

    GT: Filter.Operator.ValueType  # 2
    """greater than"""

    GE: Filter.Operator.ValueType  # 3
    """greater than or equal to"""

    LT: Filter.Operator.ValueType  # 4
    """less than"""

    LE: Filter.Operator.ValueType  # 5
    """less than or equal to"""

    RE: Filter.Operator.ValueType  # 6
    """regex"""

    NRE: Filter.Operator.ValueType  # 7
    """not regex"""

    IN: Filter.Operator.ValueType  # 8
    """in"""

    NIN: Filter.Operator.ValueType  # 9
    """not in"""

    SUB: Filter.Operator.ValueType  # 10
    """substring (prefix substring)"""

    WILDCARD: Filter.Operator.ValueType  # 11
    """wildcard query (for custom index only)"""

    BITMASK: Filter.Operator.ValueType  # 16
    """filter on bitmask bit(s) are set. Only applicable for integer fields"""

    LOGICALOR: Filter.Operator.ValueType  # 20
    """Logical OR operator to be used between two filters"""

    LOGICALAND: Filter.Operator.ValueType  # 21
    """Logical AND operator to be used between two filters"""


    class Value(google.protobuf.message.Message):
        """Value, normalized"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        STR_FIELD_NUMBER: builtins.int
        INT_FIELD_NUMBER: builtins.int
        UINT_FIELD_NUMBER: builtins.int
        FLOAT_FIELD_NUMBER: builtins.int
        B_FIELD_NUMBER: builtins.int
        IP_FIELD_NUMBER: builtins.int
        MAC_FIELD_NUMBER: builtins.int
        COMP_FIELD_NUMBER: builtins.int
        MULTI_FIELD_NUMBER: builtins.int
        str: typing.Text
        int: builtins.int
        uint: builtins.int
        float: builtins.float
        b: builtins.bool
        ip: typing.Text
        mac: typing.Text
        @property
        def comp(self) -> global___Filter.ComponentValue: ...
        @property
        def multi(self) -> global___Filter.MultiValue: ...
        def __init__(self,
            *,
            str: typing.Text = ...,
            int: builtins.int = ...,
            uint: builtins.int = ...,
            float: builtins.float = ...,
            b: builtins.bool = ...,
            ip: typing.Text = ...,
            mac: typing.Text = ...,
            comp: typing.Optional[global___Filter.ComponentValue] = ...,
            multi: typing.Optional[global___Filter.MultiValue] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["b",b"b","comp",b"comp","float",b"float","int",b"int","ip",b"ip","kind",b"kind","mac",b"mac","multi",b"multi","str",b"str","uint",b"uint"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["b",b"b","comp",b"comp","float",b"float","int",b"int","ip",b"ip","kind",b"kind","mac",b"mac","multi",b"multi","str",b"str","uint",b"uint"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["kind",b"kind"]) -> typing.Optional[typing_extensions.Literal["str","int","uint","float","b","ip","mac","comp","multi"]]: ...

    class ComponentValue(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class ValueEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: typing.Text
            value: typing.Text
            def __init__(self,
                *,
                key: typing.Text = ...,
                value: typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

        VALUE_FIELD_NUMBER: builtins.int
        @property
        def value(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]: ...
        def __init__(self,
            *,
            value: typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["value",b"value"]) -> None: ...

    class MultiValue(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        VALUES_FIELD_NUMBER: builtins.int
        @property
        def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Filter.Value]: ...
        def __init__(self,
            *,
            values: typing.Optional[typing.Iterable[global___Filter.Value]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["values",b"values"]) -> None: ...

    FIELD_FIELD_NUMBER: builtins.int
    OP_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    NESTED_FIELD_FIELD_NUMBER: builtins.int
    SUB_FILTERS_FIELD_NUMBER: builtins.int
    field: typing.Text
    op: global___Filter.Operator.ValueType
    @property
    def value(self) -> global___Filter.Value: ...
    @property
    def nested_field(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """nested_field to support nested fields. a.b.c needs to specified as ["a","b","c"]."""
        pass
    @property
    def sub_filters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Filter]:
        """sub_filters to specify complex predicate using logical operators.
        Complex predicates are specified as recursive definition of filters.
        Different levels are used to resemble abstract syntaxt tree like structure.
        """
        pass
    def __init__(self,
        *,
        field: typing.Text = ...,
        op: global___Filter.Operator.ValueType = ...,
        value: typing.Optional[global___Filter.Value] = ...,
        nested_field: typing.Optional[typing.Iterable[typing.Text]] = ...,
        sub_filters: typing.Optional[typing.Iterable[global___Filter]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["field",b"field","nested_field",b"nested_field","op",b"op","sub_filters",b"sub_filters","value",b"value"]) -> None: ...
global___Filter = Filter

class Aggregate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Type:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Aggregate._Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        Invalid: Aggregate._Type.ValueType  # 0
        TERM: Aggregate._Type.ValueType  # 1
        """Type of bucket aggregation where different buckets are created based on field values"""

        SUM: Aggregate._Type.ValueType  # 2
        """SUM aggregation where numeric summation is calculated on field values"""

        AVG: Aggregate._Type.ValueType  # 3
        """AVG aggregation where numeric average is calculated on field values"""

        MAX: Aggregate._Type.ValueType  # 4
        """MAX aggregation where numeric maximum is returned amongst the field values"""

        MIN: Aggregate._Type.ValueType  # 5
        """MIN aggregation where numeric minimum is returned amongst the field values"""

        HIST: Aggregate._Type.ValueType  # 6
        """histogram bucketing/aggregation on numeric field value"""

    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        pass

    Invalid: Aggregate.Type.ValueType  # 0
    TERM: Aggregate.Type.ValueType  # 1
    """Type of bucket aggregation where different buckets are created based on field values"""

    SUM: Aggregate.Type.ValueType  # 2
    """SUM aggregation where numeric summation is calculated on field values"""

    AVG: Aggregate.Type.ValueType  # 3
    """AVG aggregation where numeric average is calculated on field values"""

    MAX: Aggregate.Type.ValueType  # 4
    """MAX aggregation where numeric maximum is returned amongst the field values"""

    MIN: Aggregate.Type.ValueType  # 5
    """MIN aggregation where numeric minimum is returned amongst the field values"""

    HIST: Aggregate.Type.ValueType  # 6
    """histogram bucketing/aggregation on numeric field value"""


    AGGR_TYPE_FIELD_NUMBER: builtins.int
    FIELDS_FIELD_NUMBER: builtins.int
    SORT_FIELD_NUMBER: builtins.int
    SUB_AGGRS_FIELD_NUMBER: builtins.int
    TERM_FIELD_NUMBER: builtins.int
    HIST_FIELD_NUMBER: builtins.int
    aggr_type: global___Aggregate.Type.ValueType
    """Type of aggregation being requested"""

    @property
    def fields(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Field on which aggregation operation needs to be applied
        Nested field like a.b.c needs to specified as ["a","b","c"].
        It is not possible to combine fields only for aggregation operation.
        All the combinations need to be predecided at schema creation time only.
        """
        pass
    sort: global___SortType.ValueType
    """For sorting on aggregated outcome. Applicable only for numeric aggregation."""

    @property
    def sub_aggrs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Aggregate]:
        """For specifying sub aggregation, like sum aggregation inside bucket aggregation."""
        pass
    @property
    def term(self) -> global___term_options:
        """Option for term aggregation"""
        pass
    @property
    def hist(self) -> global___hist_options:
        """Option for histogram aggregation"""
        pass
    def __init__(self,
        *,
        aggr_type: global___Aggregate.Type.ValueType = ...,
        fields: typing.Optional[typing.Iterable[typing.Text]] = ...,
        sort: global___SortType.ValueType = ...,
        sub_aggrs: typing.Optional[typing.Iterable[global___Aggregate]] = ...,
        term: typing.Optional[global___term_options] = ...,
        hist: typing.Optional[global___hist_options] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["Option",b"Option","hist",b"hist","term",b"term"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["Option",b"Option","aggr_type",b"aggr_type","fields",b"fields","hist",b"hist","sort",b"sort","sub_aggrs",b"sub_aggrs","term",b"term"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["Option",b"Option"]) -> typing.Optional[typing_extensions.Literal["term","hist"]]: ...
global___Aggregate = Aggregate

class term_options(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Type:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[term_options._Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNSPECIFIED: term_options._Type.ValueType  # 0
        BOOL: term_options._Type.ValueType  # 1
        DOUBLE: term_options._Type.ValueType  # 2
        LONG: term_options._Type.ValueType  # 3
        STRING: term_options._Type.ValueType  # 4
        COMPONENT: term_options._Type.ValueType  # 5
        IP: term_options._Type.ValueType  # 6
        MAC: term_options._Type.ValueType  # 7
    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        """For providing type hint"""
        pass

    UNSPECIFIED: term_options.Type.ValueType  # 0
    BOOL: term_options.Type.ValueType  # 1
    DOUBLE: term_options.Type.ValueType  # 2
    LONG: term_options.Type.ValueType  # 3
    STRING: term_options.Type.ValueType  # 4
    COMPONENT: term_options.Type.ValueType  # 5
    IP: term_options.Type.ValueType  # 6
    MAC: term_options.Type.ValueType  # 7

    NUM_OF_BUCKETS_FIELD_NUMBER: builtins.int
    FIELD_TYPE_FIELD_NUMBER: builtins.int
    num_of_buckets: builtins.int
    """For controlling maximum number of buckets"""

    field_type: global___term_options.Type.ValueType
    def __init__(self,
        *,
        num_of_buckets: builtins.int = ...,
        field_type: global___term_options.Type.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["field_type",b"field_type","num_of_buckets",b"num_of_buckets"]) -> None: ...
global___term_options = term_options

class hist_options(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class bounds(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        MIN_FIELD_NUMBER: builtins.int
        MAX_FIELD_NUMBER: builtins.int
        min: builtins.int
        max: builtins.int
        def __init__(self,
            *,
            min: builtins.int = ...,
            max: builtins.int = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["max",b"max","min",b"min"]) -> None: ...

    INTERVAL_FIELD_NUMBER: builtins.int
    ALLOW_EMPTY_FIELD_NUMBER: builtins.int
    EXTENDED_BOUNDS_FIELD_NUMBER: builtins.int
    interval: builtins.int
    """mandatory"""

    allow_empty: builtins.bool
    """optional"""

    @property
    def extended_bounds(self) -> global___hist_options.bounds:
        """specify bounding box beyond min/max returned from query, together with allow_empty"""
        pass
    def __init__(self,
        *,
        interval: builtins.int = ...,
        allow_empty: builtins.bool = ...,
        extended_bounds: typing.Optional[global___hist_options.bounds] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["extended_bounds",b"extended_bounds"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["allow_empty",b"allow_empty","extended_bounds",b"extended_bounds","interval",b"interval"]) -> None: ...
global___hist_options = hist_options

class SearchRequestWithAggr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    SEARCH_FIELD_NUMBER: builtins.int
    AGGRS_FIELD_NUMBER: builtins.int
    @property
    def search(self) -> global___SearchRequest:
        """Search criteria within aggregation request"""
        pass
    @property
    def aggrs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Aggregate]:
        """Aggregation clauses"""
        pass
    def __init__(self,
        *,
        search: typing.Optional[global___SearchRequest] = ...,
        aggrs: typing.Optional[typing.Iterable[global___Aggregate]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["search",b"search"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["aggrs",b"aggrs","search",b"search"]) -> None: ...
global___SearchRequestWithAggr = SearchRequestWithAggr

class ByteStream(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    MESSAGE_FIELD_NUMBER: builtins.int
    message: builtins.bytes
    """Message is an array of bytes"""

    def __init__(self,
        *,
        message: builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["message",b"message"]) -> None: ...
global___ByteStream = ByteStream

class AggrResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    BUCKETS_FIELD_NUMBER: builtins.int
    FIELDS_FIELD_NUMBER: builtins.int
    @property
    def buckets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AggrBucket]:
        """Buckets in aggregation response"""
        pass
    @property
    def fields(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AggrField]:
        """Numeric fields in aggregation response"""
        pass
    def __init__(self,
        *,
        buckets: typing.Optional[typing.Iterable[global___AggrBucket]] = ...,
        fields: typing.Optional[typing.Iterable[global___AggrField]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["buckets",b"buckets","fields",b"fields"]) -> None: ...
global___AggrResponse = AggrResponse

class AggrBucket(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEY_FIELD_NUMBER: builtins.int
    COUNT_FIELD_NUMBER: builtins.int
    AGGR_NAME_FIELD_NUMBER: builtins.int
    FIELDS_FIELD_NUMBER: builtins.int
    SUB_BUCKETS_FIELD_NUMBER: builtins.int
    key: typing.Text
    """key of the bucket"""

    count: builtins.int
    """count of matching document"""

    aggr_name: typing.Text
    """aggr_name has name of the aggregation to which these buckets belong to
    this is useful when there are multiple top level aggregations
    Name is formed by prepending aggregation type to the field name
    for term aggreation with field ["a","b","c"] name would be termabc
    """

    @property
    def fields(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AggrField]:
        """Numeric fields in this bucket"""
        pass
    @property
    def sub_buckets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AggrBucket]:
        """Sub buckets within this bucket"""
        pass
    def __init__(self,
        *,
        key: typing.Text = ...,
        count: builtins.int = ...,
        aggr_name: typing.Text = ...,
        fields: typing.Optional[typing.Iterable[global___AggrField]] = ...,
        sub_buckets: typing.Optional[typing.Iterable[global___AggrBucket]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["aggr_name",b"aggr_name","count",b"count","fields",b"fields","key",b"key","sub_buckets",b"sub_buckets"]) -> None: ...
global___AggrBucket = AggrBucket

class AggrField(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    name: typing.Text
    """Name of the field
    Name is formed by prepending aggregation type to the field name.
    SUM for field ["a","b","c"] would be SUMabc
    """

    value: builtins.float
    """Field value"""

    def __init__(self,
        *,
        name: typing.Text = ...,
        value: builtins.float = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name","value",b"value"]) -> None: ...
global___AggrField = AggrField

class IndexField(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    SUB_FIELD_FIELD_NUMBER: builtins.int
    name: typing.Text
    type: global___IndexDataType.ValueType
    @property
    def sub_field(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___IndexField]: ...
    def __init__(self,
        *,
        name: typing.Text = ...,
        type: global___IndexDataType.ValueType = ...,
        sub_field: typing.Optional[typing.Iterable[global___IndexField]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name","sub_field",b"sub_field","type",b"type"]) -> None: ...
global___IndexField = IndexField

class CustomIndexOptions(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    DELETE_AFTER_DAYS_FIELD_NUMBER: builtins.int
    INUSE_DELETE_AFTER_DAYS_FIELD_NUMBER: builtins.int
    delete_after_days: builtins.int
    """delete_after_days is requested days after which data should get deleted"""

    inuse_delete_after_days: builtins.int
    """inuse_delete_after_days is what is actually in use.
    This is guaranteed to be atleast delete_after_days.
    delete_after_days may get modified based on index rotation policy by Cloudvision
    """

    def __init__(self,
        *,
        delete_after_days: builtins.int = ...,
        inuse_delete_after_days: builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["delete_after_days",b"delete_after_days","inuse_delete_after_days",b"inuse_delete_after_days"]) -> None: ...
global___CustomIndexOptions = CustomIndexOptions

class CustomIndexSchema(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    QUERY_FIELD_NUMBER: builtins.int
    SCHEMA_FIELD_NUMBER: builtins.int
    OPTION_FIELD_NUMBER: builtins.int
    @property
    def query(self) -> global___Query: ...
    @property
    def schema(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___IndexField]: ...
    @property
    def option(self) -> global___CustomIndexOptions: ...
    def __init__(self,
        *,
        query: typing.Optional[global___Query] = ...,
        schema: typing.Optional[typing.Iterable[global___IndexField]] = ...,
        option: typing.Optional[global___CustomIndexOptions] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["option",b"option","query",b"query"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["option",b"option","query",b"query","schema",b"schema"]) -> None: ...
global___CustomIndexSchema = CustomIndexSchema

class CustomIndexSchemaDel(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    QUERY_FIELD_NUMBER: builtins.int
    DELETE_DATA_FIELD_NUMBER: builtins.int
    @property
    def query(self) -> global___Query: ...
    delete_data: builtins.bool
    """if delete_data is set, then all the data along with schema defintion is deleted.
    Data deletion is non recoverable operation !
    """

    def __init__(self,
        *,
        query: typing.Optional[global___Query] = ...,
        delete_data: builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["query",b"query"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["delete_data",b"delete_data","query",b"query"]) -> None: ...
global___CustomIndexSchemaDel = CustomIndexSchemaDel

class PublishRequest(google.protobuf.message.Message):
    """PublishRequest"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    BATCH_FIELD_NUMBER: builtins.int
    SYNC_FIELD_NUMBER: builtins.int
    COMPARE_FIELD_NUMBER: builtins.int
    @property
    def batch(self) -> notification_pb2.NotificationBatch:
        """The batch of notification sent to Cloudvision"""
        pass
    sync: builtins.bool
    """Used to have a synchronous or asynchronous write to the Cloudvision storage"""

    @property
    def compare(self) -> notification_pb2.Notification.Update:
        """If provided, the batch notification will be stored only if one of the
        following conditions are true:
        a) compare.value matches the current value stored for field compare.key
        b) compare.value is not provided and the compare.key field does not exist
           in the specified dataset path
        The comparison and storage operations are guaranteed to occur atomically
        per notification, so only one notification is expected in the batch.
        This parameter can be encoded using EncodeNotificationUpdate or
        EncodeNotificationUpdateKey for conditions a) and b), respectively.
        """
        pass
    def __init__(self,
        *,
        batch: typing.Optional[notification_pb2.NotificationBatch] = ...,
        sync: builtins.bool = ...,
        compare: typing.Optional[notification_pb2.Notification.Update] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["batch",b"batch","compare",b"compare"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["batch",b"batch","compare",b"compare","sync",b"sync"]) -> None: ...
global___PublishRequest = PublishRequest

class DatasetsRequest(google.protobuf.message.Message):
    """DatasetsRequest"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    TYPES_FIELD_NUMBER: builtins.int
    SHARDED_SUB_FIELD_NUMBER: builtins.int
    PARENT_FIELD_NUMBER: builtins.int
    @property
    def types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
    @property
    def sharded_sub(self) -> sharding_pb2.Sharding: ...
    @property
    def parent(self) -> notification_pb2.Dataset: ...
    def __init__(self,
        *,
        types: typing.Optional[typing.Iterable[typing.Text]] = ...,
        sharded_sub: typing.Optional[sharding_pb2.Sharding] = ...,
        parent: typing.Optional[notification_pb2.Dataset] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["parent",b"parent","sharded_sub",b"sharded_sub"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["parent",b"parent","sharded_sub",b"sharded_sub","types",b"types"]) -> None: ...
global___DatasetsRequest = DatasetsRequest

class DatasetsResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    DATASETS_FIELD_NUMBER: builtins.int
    @property
    def datasets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[notification_pb2.Dataset]: ...
    def __init__(self,
        *,
        datasets: typing.Optional[typing.Iterable[notification_pb2.Dataset]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["datasets",b"datasets"]) -> None: ...
global___DatasetsResponse = DatasetsResponse

class CreateDatasetRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    DATASET_FIELD_NUMBER: builtins.int
    @property
    def dataset(self) -> notification_pb2.Dataset: ...
    def __init__(self,
        *,
        dataset: typing.Optional[notification_pb2.Dataset] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["dataset",b"dataset"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["dataset",b"dataset"]) -> None: ...
global___CreateDatasetRequest = CreateDatasetRequest

class SetPermissionRequest(google.protobuf.message.Message):
    """SetPermissionRequest encompasses requests to create/update/delete permissions of each type.
    A PATH_PERMISSION must contain a set of path<->permission tuples.
    The INHERIT_PERMISSION only requires the @dataset and @other args.
    ADMIN_PERMISSION reuses @path but only looks at the @perm field of the first element.
    Updates require the the client to pass `oldPerm` to avoid race conditions.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Type:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[SetPermissionRequest._Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        PATH_PERMISSION: SetPermissionRequest._Type.ValueType  # 0
        INHERIT_PERMISSION: SetPermissionRequest._Type.ValueType  # 1
        UNINHERIT_PERMISSION: SetPermissionRequest._Type.ValueType  # 2
        ADMIN_PERMISSION: SetPermissionRequest._Type.ValueType  # 3
        SET_ROLE_PERMISSION: SetPermissionRequest._Type.ValueType  # 4
        REMOVE_ROLE_PERMISSION: SetPermissionRequest._Type.ValueType  # 5
    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        pass

    PATH_PERMISSION: SetPermissionRequest.Type.ValueType  # 0
    INHERIT_PERMISSION: SetPermissionRequest.Type.ValueType  # 1
    UNINHERIT_PERMISSION: SetPermissionRequest.Type.ValueType  # 2
    ADMIN_PERMISSION: SetPermissionRequest.Type.ValueType  # 3
    SET_ROLE_PERMISSION: SetPermissionRequest.Type.ValueType  # 4
    REMOVE_ROLE_PERMISSION: SetPermissionRequest.Type.ValueType  # 5

    class PathPerm(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _Perm:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _PermEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[SetPermissionRequest.PathPerm._Perm.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            NULL_PERM_VALUE: SetPermissionRequest.PathPerm._Perm.ValueType  # 0
            READ_PERM: SetPermissionRequest.PathPerm._Perm.ValueType  # 1
            WRITE_PERM: SetPermissionRequest.PathPerm._Perm.ValueType  # 2
            READ_WRITE_PERM: SetPermissionRequest.PathPerm._Perm.ValueType  # 3
        class Perm(_Perm, metaclass=_PermEnumTypeWrapper):
            pass

        NULL_PERM_VALUE: SetPermissionRequest.PathPerm.Perm.ValueType  # 0
        READ_PERM: SetPermissionRequest.PathPerm.Perm.ValueType  # 1
        WRITE_PERM: SetPermissionRequest.PathPerm.Perm.ValueType  # 2
        READ_WRITE_PERM: SetPermissionRequest.PathPerm.Perm.ValueType  # 3

        PATH_FIELD_NUMBER: builtins.int
        NEWPERM_FIELD_NUMBER: builtins.int
        CURRENTPERM_FIELD_NUMBER: builtins.int
        EXACTMATCH_FIELD_NUMBER: builtins.int
        @property
        def path(self) -> global___Path: ...
        newPerm: global___SetPermissionRequest.PathPerm.Perm.ValueType
        currentPerm: global___SetPermissionRequest.PathPerm.Perm.ValueType
        exactMatch: builtins.bool
        def __init__(self,
            *,
            path: typing.Optional[global___Path] = ...,
            newPerm: global___SetPermissionRequest.PathPerm.Perm.ValueType = ...,
            currentPerm: global___SetPermissionRequest.PathPerm.Perm.ValueType = ...,
            exactMatch: builtins.bool = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["path",b"path"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["currentPerm",b"currentPerm","exactMatch",b"exactMatch","newPerm",b"newPerm","path",b"path"]) -> None: ...

    TYPE_FIELD_NUMBER: builtins.int
    DATASET_FIELD_NUMBER: builtins.int
    OTHER_FIELD_NUMBER: builtins.int
    PATHPERMS_FIELD_NUMBER: builtins.int
    type: global___SetPermissionRequest.Type.ValueType
    @property
    def dataset(self) -> notification_pb2.Dataset: ...
    @property
    def other(self) -> notification_pb2.Dataset: ...
    @property
    def pathPerms(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SetPermissionRequest.PathPerm]: ...
    def __init__(self,
        *,
        type: global___SetPermissionRequest.Type.ValueType = ...,
        dataset: typing.Optional[notification_pb2.Dataset] = ...,
        other: typing.Optional[notification_pb2.Dataset] = ...,
        pathPerms: typing.Optional[typing.Iterable[global___SetPermissionRequest.PathPerm]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["dataset",b"dataset","other",b"other"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["dataset",b"dataset","other",b"other","pathPerms",b"pathPerms","type",b"type"]) -> None: ...
global___SetPermissionRequest = SetPermissionRequest

class PermissionSet(google.protobuf.message.Message):
    """A PermissionSet can be represented as a list of SetPermissionRequests"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PERMISSIONS_FIELD_NUMBER: builtins.int
    @property
    def permissions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SetPermissionRequest]: ...
    def __init__(self,
        *,
        permissions: typing.Optional[typing.Iterable[global___SetPermissionRequest]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["permissions",b"permissions"]) -> None: ...
global___PermissionSet = PermissionSet

class ClusterDescription(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    TIMESTAMP_FIELD_NUMBER: builtins.int
    CLUSTERNAME_FIELD_NUMBER: builtins.int
    EPOCH_FIELD_NUMBER: builtins.int
    @property
    def timestamp(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """timestamp represent the server's current time."""
        pass
    clusterName: typing.Text
    epoch: builtins.int
    def __init__(self,
        *,
        timestamp: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        clusterName: typing.Text = ...,
        epoch: builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["timestamp",b"timestamp"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["clusterName",b"clusterName","epoch",b"epoch","timestamp",b"timestamp"]) -> None: ...
global___ClusterDescription = ClusterDescription

class SetPasswordRequest(google.protobuf.message.Message):
    """SetPasswordRequest is used to set the password for a dataset."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    DATASET_FIELD_NUMBER: builtins.int
    PASSWORD_FIELD_NUMBER: builtins.int
    @property
    def dataset(self) -> notification_pb2.Dataset: ...
    password: typing.Text
    def __init__(self,
        *,
        dataset: typing.Optional[notification_pb2.Dataset] = ...,
        password: typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["dataset",b"dataset"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["dataset",b"dataset","password",b"password"]) -> None: ...
global___SetPasswordRequest = SetPasswordRequest

class CreateSessionRequest(google.protobuf.message.Message):
    """CreateSessionRequest is used to create session for user"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    DATASET_FIELD_NUMBER: builtins.int
    TIMEOUT_FIELD_NUMBER: builtins.int
    @property
    def dataset(self) -> notification_pb2.Dataset: ...
    timeout: builtins.int
    def __init__(self,
        *,
        dataset: typing.Optional[notification_pb2.Dataset] = ...,
        timeout: builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["dataset",b"dataset"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["dataset",b"dataset","timeout",b"timeout"]) -> None: ...
global___CreateSessionRequest = CreateSessionRequest

class CreateSessionResponse(google.protobuf.message.Message):
    """CreateSessionResponse returns the issued JWT token"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    JWTTOKEN_FIELD_NUMBER: builtins.int
    EXPIRY_FIELD_NUMBER: builtins.int
    jwtToken: typing.Text
    expiry: builtins.int
    def __init__(self,
        *,
        jwtToken: typing.Text = ...,
        expiry: builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["expiry",b"expiry","jwtToken",b"jwtToken"]) -> None: ...
global___CreateSessionResponse = CreateSessionResponse

class SQLRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    QUERY_FIELD_NUMBER: builtins.int
    ARGS_FIELD_NUMBER: builtins.int
    query: typing.Text
    @property
    def args(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bytes]:
        """Neat encoded values for the arguments to the stmt query"""
        pass
    def __init__(self,
        *,
        query: typing.Text = ...,
        args: typing.Optional[typing.Iterable[builtins.bytes]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["args",b"args","query",b"query"]) -> None: ...
global___SQLRequest = SQLRequest

class SQLResponseRow(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUES_FIELD_NUMBER: builtins.int
    @property
    def values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bytes]:
        """NEAT encoded values for one row"""
        pass
    def __init__(self,
        *,
        values: typing.Optional[typing.Iterable[builtins.bytes]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["values",b"values"]) -> None: ...
global___SQLResponseRow = SQLResponseRow

class SQLResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Metadata(google.protobuf.message.Message):
        """Metadata, usually returned with the first response.
        But it could return some metadata on any subsequent response, including the last one.
        The message can contain partial data
        (for instance, columns will be only in the first answer)
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        COLUMNS_FIELD_NUMBER: builtins.int
        @property
        def columns(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """Name of the columns for the query result returned
            Returned only in the first response message.
            """
            pass
        def __init__(self,
            *,
            columns: typing.Optional[typing.Iterable[typing.Text]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["columns",b"columns"]) -> None: ...

    ROWS_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    @property
    def rows(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SQLResponseRow]: ...
    @property
    def metadata(self) -> global___SQLResponse.Metadata: ...
    def __init__(self,
        *,
        rows: typing.Optional[typing.Iterable[global___SQLResponseRow]] = ...,
        metadata: typing.Optional[global___SQLResponse.Metadata] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["metadata",b"metadata"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["metadata",b"metadata","rows",b"rows"]) -> None: ...
global___SQLResponse = SQLResponse
